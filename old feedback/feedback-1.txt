============================================
vis/output.txt
16:46:17_Tuesday_29_August_2017
============================================

Compiling with gcc -Wall -std=c99 ... 
Compilation succeeded.
==7093== Memcheck, a memory error detector
==7093== Copyright (C) 2002-2012, and GNU GPL'd, by Julian Seward et al.
==7093== Using Valgrind-3.8.1 and LibVEX; rerun with -h for copyright info
==7093== Command: flow ../data/flow_data.csv 24
==7093== 
TASK1: 1529.65 milliseconds
TASK2: 6982.57 milliseconds
TASK3: 7424.74 milliseconds
TASK4: 17.49 milliseconds
==7093== 
==7093== HEAP SUMMARY:
==7093==     in use at exit: 0 bytes in 0 blocks
==7093==   total heap usage: 1,804,903 allocs, 1,804,903 frees, 2,652,167,495 bytes allocated
==7093== 
==7093== All heap blocks were freed -- no leaks are possible
==7093== 
==7093== For counts of detected and suppressed errors, rerun with: -v
==7093== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 6 from 6)
============================================
Test for input file: flow_data.csv
Files ../data/TRUE_SOLN.txt and vis/sebastianb1-output.txt differ
 
Oops, your results seem to be INCORRECT.  :(
 
 
Your wake profile seems to be CORRECT.  :)
 
============================================
vis/sebastianb1-output.txt
16:46:17_Tuesday_29_August_2017
============================================
======================================================
                      TASK 1                          
======================================================
x,y,u,v
20.011999,-5.430400,1.024000,-0.001540
20.011999,-0.080000,0.707800,0.000097
20.011999,-1.403700,0.827750,0.006426
20.011999,1.200500,0.808700,-0.006204
======================================================
                      TASK 2                          
======================================================
x,y,u,v,S
11.001404,-3.495982,1.021370,-0.004076,8.848064
11.001404,3.504128,1.021168,0.004030,8.844421
11.001401,-2.483021,0.978054,-0.000250,8.672128
11.001401,2.486053,0.976347,-0.000383,8.656478
11.001406,-4.502311,1.027413,-0.005055,8.643241
11.001409,-5.528028,1.026272,-0.005252,8.335525
11.001411,-6.509244,1.024960,-0.005464,8.018356
11.001400,1.471829,0.867435,-0.006138,7.815337
11.001400,-1.471531,0.863641,0.005338,7.781134
11.001411,-7.498061,1.023537,-0.005680,7.688021
13.010290,-3.495983,1.016773,-0.002749,7.547440
13.010290,3.504129,1.015799,0.002654,7.539023
13.010291,-4.502316,1.026552,-0.004031,7.456511
11.001410,-8.524317,1.021990,-0.005877,7.343357
13.010294,-2.483023,0.968049,0.001063,7.308726
13.010294,2.486056,0.965639,-0.001506,7.290222
13.010294,-5.528026,1.025840,-0.004323,7.256989
13.010297,-6.509244,1.024514,-0.004516,7.042475
11.001409,-9.506059,1.020483,-0.006023,7.018829
13.010297,-7.498065,1.023121,-0.004698,6.813482
11.001409,-10.487545,1.018982,-0.006118,6.704246
14.991937,-3.495985,1.011796,-0.001586,6.572608
13.010297,-8.524311,1.021638,-0.004866,6.568339
14.991937,3.504131,1.009928,0.001322,6.559679
13.010298,1.471828,0.858781,-0.005908,6.559093
14.991938,-4.502324,1.025342,-0.003042,6.550309
13.010298,-1.471532,0.852845,0.006353,6.513802
14.991940,-5.528014,1.025376,-0.003422,6.417198
11.001409,-11.531303,1.017434,-0.006165,6.384040
13.010296,-9.506052,1.020210,-0.004999,6.331620
14.991939,-2.483020,0.959085,0.002000,6.311375
14.991939,2.486059,0.957357,-0.002326,6.299802
14.991941,-6.509242,1.024086,-0.003632,6.265838
11.001399,0.500000,0.673901,-0.005805,6.119507
14.991941,-7.498065,1.022732,-0.003821,6.101376
13.010296,-10.487543,1.018803,-0.005101,6.096693
11.001406,-12.554368,1.015971,-0.006160,6.086468
11.001399,-0.500000,0.664806,0.005672,6.036912
14.991942,-8.524302,1.021306,-0.003994,5.922056
13.010296,-11.531302,1.017348,-0.005173,5.851943
16.988827,-4.502324,1.023881,-0.002134,5.825693
11.001406,-13.544328,1.014648,-0.006113,5.814924
16.988832,-3.495984,1.006527,-0.000504,5.803046
16.988832,3.504131,1.003899,0.000193,5.787346
14.991942,-9.506052,1.019938,-0.004136,5.745619
16.988831,-5.528012,1.024843,-0.002599,5.736423
14.991942,1.471828,0.852371,-0.005965,5.658460
16.988834,-6.509240,1.023618,-0.002831,5.626414
13.010296,-12.554366,1.015995,-0.005209,5.619569
14.991942,-1.471532,0.844003,0.006547,5.602957
11.001403,-14.488786,1.013453,-0.006036,5.570913
14.991942,-10.487544,1.018596,-0.004252,5.567334
16.988865,-2.483020,0.950782,0.002776,5.537693
16.988865,2.486058,0.950148,-0.003124,5.533861
16.988834,-7.498066,1.022319,-0.003038,5.505269
13.010296,-13.544328,1.014706,-0.005213,5.402977
14.991942,-11.531301,1.017207,-0.004346,5.378190
16.988836,-8.524306,1.020943,-0.003227,5.371296
11.001406,-15.468836,1.012310,-0.005928,5.333097
13.010300,0.500000,0.689027,-0.004939,5.292243
16.988842,-9.506055,1.019631,-0.003383,5.237620
18.987625,-4.502324,1.022067,-0.001324,5.237581
13.010300,-0.500000,0.680370,0.005561,5.225792
13.010295,-14.488787,1.013599,-0.005190,5.205253
14.991942,-12.554363,1.015903,-0.004412,5.195342
18.987625,-3.495982,1.001291,0.000490,5.186215
18.987627,-5.528012,1.024194,-0.001879,5.178993
18.987625,3.504132,0.998151,-0.000571,5.169557
11.001403,-16.480375,1.011215,-0.005796,5.103370
16.988842,-10.487543,1.018341,-0.003516,5.100612
18.987631,-6.509238,1.023105,-0.002142,5.097092
14.991942,-13.544330,1.014700,-0.004450,5.022288
13.010296,-15.468836,1.012499,-0.005144,5.009289
18.987631,-7.498065,1.021863,-0.002366,5.005593
16.988880,1.471829,0.847222,-0.006297,4.968448
16.988842,-11.531298,1.017012,-0.003631,4.953166
18.987627,2.486060,0.943666,-0.003612,4.927875
18.987627,-2.483017,0.943448,0.003624,4.926839
16.988880,-1.471533,0.838731,0.006302,4.918665
18.987633,-8.524317,1.020549,-0.002569,4.903362
11.001403,-17.427809,1.010273,-0.005656,4.902006
14.991941,-14.488791,1.013602,-0.004465,4.861668
13.010295,-16.480375,1.011450,-0.005075,4.817198
16.988842,-12.554363,1.015760,-0.003721,4.808541
18.987631,-9.506061,1.019293,-0.002739,4.800236
20.974392,-4.502323,1.019920,-0.000691,4.754391
20.974388,-5.528011,1.023483,-0.001320,4.718550
14.991942,-15.468836,1.012590,-0.004461,4.700657
18.987631,-10.487553,1.018052,-0.002885,4.693351
11.001406,-18.498287,1.009300,-0.005486,4.689581
20.974390,-3.495982,0.996099,0.001197,4.684499
14.991943,0.500000,0.702551,-0.004665,4.683689
16.988842,-13.544330,1.014616,-0.003785,4.669838
20.974390,3.504131,0.992971,-0.001071,4.669493
20.974384,-6.509238,1.022572,-0.001590,4.656270
13.010295,-17.427805,1.010538,-0.004995,4.646536
14.991943,-0.499999,0.696069,0.004932,4.640490
20.974384,-7.498065,1.021394,-0.001817,4.585526
18.987631,-11.531287,1.016774,-0.003017,4.577016
14.991941,-16.480375,1.011561,-0.004438,4.540436
16.988844,-14.488793,1.013582,-0.003829,4.539513
20.974382,-8.524317,1.020136,-0.002025,4.505827
11.001403,-19.595387,1.008398,-0.005303,4.487328
13.010296,-18.498308,1.009592,-0.004890,4.464237
18.987631,-12.554351,1.015574,-0.003125,4.461586
20.974386,2.486061,0.937794,-0.003794,4.440095
20.974386,-2.483018,0.937057,0.004072,4.436684
18.987627,1.471827,0.844013,-0.006158,4.431893
20.974379,-9.506059,1.018929,-0.002201,4.424747
16.988842,-15.468837,1.012567,-0.003855,4.407058
14.991941,-17.427799,1.010683,-0.004402,4.396450
18.987627,-1.471532,0.835934,0.006251,4.389479
18.987631,-13.544333,1.014466,-0.003209,4.349592
22.968554,-4.502323,1.017492,-0.000203,4.347202
20.974379,-10.487557,1.017737,-0.002355,4.340000
22.968557,-5.528011,1.022769,-0.000898,4.329287
13.010295,-19.595387,1.008704,-0.004771,4.288535
22.968563,-6.509238,1.022049,-0.001159,4.281178
16.988844,-16.480375,1.011580,-0.003867,4.273882
22.968552,-3.495983,0.991178,0.001587,4.266243
22.968552,3.504129,0.988266,-0.001429,4.253479
20.974379,-11.531286,1.016508,-0.002498,4.246926
18.987633,-14.488800,1.013470,-0.003273,4.243284
14.991942,-18.498310,1.009763,-0.004346,4.240849
22.968563,-7.498065,1.020925,-0.001377,4.225430
16.988886,0.500000,0.716233,-0.004243,4.214140
16.988886,-0.499999,0.709965,0.004014,4.177253
22.968567,-8.524318,1.019718,-0.001581,4.162226
20.974379,-12.554346,1.015349,-0.002618,4.153695
16.988844,-17.427797,1.010738,-0.003864,4.152915
18.987631,-15.468837,1.012496,-0.003324,4.134157
22.968573,-9.506057,1.018559,-0.001757,4.097515
14.991941,-19.595385,1.008901,-0.004276,4.089191
20.974379,-13.544334,1.014282,-0.002717,4.062431
22.968548,2.486063,0.932760,-0.003772,4.037483
22.968548,-2.483021,0.931684,0.004162,4.032892
22.968573,-10.487563,1.017411,-0.001913,4.029414
18.987633,-16.480379,1.011553,-0.003361,4.023340
16.988842,-18.498310,1.009851,-0.003846,4.020794
20.974384,1.471828,0.842367,-0.005833,4.006416
24.958462,-4.502322,1.015017,0.000184,4.002227
24.958460,-5.528011,1.022040,-0.000567,3.998070
20.974379,-14.488803,1.013317,-0.002796,3.975030
20.974384,-1.471531,0.835122,0.005900,3.971962
24.958460,-6.509237,1.021554,-0.000826,3.960540
22.968573,-11.531283,1.016221,-0.002061,3.954068
18.987633,-17.427788,1.010732,-0.003383,3.921662
24.958460,-7.498065,1.020476,-0.001033,3.915810
24.958462,-3.495984,0.986638,0.001883,3.914909
24.958462,3.504129,0.984057,-0.001706,3.904490
16.988844,-19.595383,1.009006,-0.003815,3.890617
20.974379,-15.468836,1.012379,-0.002863,3.884571
22.968569,-12.554336,1.015104,-0.002188,3.878052
24.958462,-8.524318,1.019315,-0.001228,3.864846
18.987627,0.500000,0.729053,-0.003651,3.838339
24.958462,-9.506056,1.018193,-0.001398,3.812390
18.987631,-18.498312,1.009862,-0.003394,3.809552
18.987627,-0.499999,0.722575,0.003551,3.804230
22.968569,-13.544337,1.014071,-0.002295,3.803061
20.974379,-16.480381,1.011466,-0.002920,3.791903
24.958462,-10.487563,1.017080,-0.001551,3.756897
22.968565,-14.488804,1.013136,-0.002384,3.730730
26.971294,-5.528010,1.021257,-0.000319,3.709349
20.974379,-17.427784,1.010670,-0.002960,3.706179
26.971294,-4.502322,1.012625,0.000431,3.703212
24.958460,2.486063,0.928722,-0.003697,3.702776
18.987633,-19.595375,1.009053,-0.003393,3.698126
24.958460,-2.483021,0.927533,0.004058,3.698087
24.958462,-11.531282,1.015927,-0.001698,3.695153
26.971291,-6.509238,1.021085,-0.000574,3.680163
22.968546,1.471828,0.841689,-0.005183,3.657096
22.968569,-15.468836,1.012228,-0.002463,3.655334
26.971291,-7.498064,1.020048,-0.000766,3.643795
24.958462,-12.554335,1.014844,-0.001827,3.632483
22.968546,-1.471532,0.835862,0.005410,3.631791
26.971294,-3.495985,0.982515,0.002043,3.612602
20.974379,-18.498314,1.009834,-0.002993,3.610917
26.971294,3.504130,0.980240,-0.001955,3.604101
26.971289,-8.524319,1.018924,-0.000948,3.602184
22.968565,-16.480391,1.011342,-0.002532,3.577529
24.958462,-13.544336,1.013844,-0.001938,3.570291
26.971287,-9.506056,1.017834,-0.001107,3.559177
20.974382,0.500000,0.739891,-0.003447,3.526629
20.974379,-19.595371,1.009043,-0.003015,3.515389
26.971287,-10.487563,1.016755,-0.001254,3.513501
24.958462,-14.488802,1.012937,-0.002033,3.509943
22.968565,-17.427792,1.010572,-0.002587,3.505049
20.974382,-0.499999,0.734722,0.002679,3.501977
26.971287,-11.531281,1.015636,-0.001396,3.462446
28.999063,-5.528008,1.020426,-0.000153,3.456582
24.958462,-15.468836,1.012053,-0.002119,3.446656
28.999067,-4.502323,1.010187,0.000608,3.442277
28.999056,-6.509240,1.020646,-0.000398,3.434136
22.968569,-18.498316,1.009760,-0.002636,3.423925
26.971292,2.486063,0.925150,-0.003722,3.415677
26.971292,-2.483019,0.924291,0.003907,3.412543
26.971281,-12.554333,1.014581,-0.001523,3.410364
28.999056,-7.498062,1.019657,-0.000567,3.404222
24.958462,-16.480396,1.011196,-0.002197,3.380953
28.999048,-8.524318,1.018562,-0.000729,3.369826
24.958460,1.471828,0.842132,-0.004762,3.368337
26.971281,-13.544338,1.013606,-0.001634,3.358417
28.999073,-3.495988,0.978718,0.002142,3.350746
24.958460,-1.471532,0.836929,0.004840,3.347530
28.999073,3.504130,0.976800,-0.002190,3.344065
22.968565,-19.595366,1.008988,-0.002676,3.341960
28.999041,-9.506056,1.017500,-0.000875,3.334170
24.958462,-17.427795,1.010445,-0.002260,3.319367
26.971281,-14.488801,1.012725,-0.001730,3.307771
28.999041,-10.487564,1.016444,-0.001011,3.296164
22.968544,0.500000,0.749351,-0.002822,3.261760
26.971281,-15.468831,1.011865,-0.001820,3.254390
28.999041,-11.531280,1.015351,-0.001146,3.253540
24.958462,-18.498322,1.009656,-0.002321,3.250018
22.968544,-0.499999,0.745588,0.002401,3.245376
30.988716,-5.528005,1.019661,-0.000066,3.239290
30.988720,-6.509243,1.020276,-0.000278,3.222095
30.988718,-4.502326,1.007845,0.000666,3.218504
28.999031,-12.554332,1.014318,-0.001268,3.209877
26.971281,-16.480398,1.011030,-0.001904,3.198678
30.988720,-7.498059,1.019325,-0.000418,3.197086
24.958462,-19.595362,1.008908,-0.002374,3.179501
30.988722,-8.524319,1.018245,-0.000559,3.168176
28.999081,2.486062,0.921987,-0.003821,3.167773
28.999031,-13.544338,1.013368,-0.001377,3.166169
28.999081,-2.483021,0.921183,0.003840,3.165041
26.971281,-17.427801,1.010298,-0.001973,3.146178
30.988726,-9.506056,1.017197,-0.000690,3.138144
30.988726,-3.495993,0.975399,0.002024,3.127758
28.999031,-14.488799,1.012507,-0.001473,3.123374
30.988726,3.504131,0.973695,-0.002319,3.122205
26.971292,1.471829,0.843015,-0.004567,3.121002
30.988726,-10.487567,1.016158,-0.000816,3.106065
26.971292,-1.471532,0.837806,0.004602,3.101723
26.971281,-18.498325,1.009530,-0.002043,3.086751
28.999031,-15.468826,1.011667,-0.001565,3.078082
30.988726,-11.531277,1.015083,-0.000943,3.069996
32.973141,-5.528005,1.018899,0.000060,3.047557
24.958458,0.500000,0.757852,-0.002456,3.035859
32.973141,-6.509243,1.019967,-0.000154,3.034757
30.988729,-12.554328,1.014071,-0.001060,3.032946
28.999031,-16.480400,1.010851,-0.001651,3.030600
26.971281,-19.595366,1.008801,-0.002104,3.025977
24.958458,-0.499999,0.754708,0.002351,3.023264
32.973137,-4.502326,1.005729,0.000785,3.022105
32.973141,-7.498059,1.019033,-0.000280,3.013560
30.988729,-13.544339,1.013136,-0.001166,2.995729
32.973141,-8.524319,1.017957,-0.000410,2.988964
28.999031,-17.427805,1.010139,-0.001724,2.985666
32.973141,-9.506056,1.016919,-0.000532,2.963388
30.988729,-14.488797,1.012294,-0.001260,2.959185
30.988737,2.486060,0.919186,-0.003781,2.956719
30.988737,-2.483023,0.918385,0.003592,2.954164
32.973141,-10.487567,1.015891,-0.000651,2.936032
28.999031,-18.498329,1.009389,-0.001798,2.934559
32.973133,-3.495993,0.972439,0.002039,2.932754
32.973133,3.504131,0.970942,-0.002287,2.928164
30.988729,-15.468817,1.011470,-0.001351,2.920369
28.999084,1.471829,0.844225,-0.004429,2.907511
32.973141,-11.531277,1.014831,-0.000772,2.905218
28.999084,-1.471532,0.838783,0.004444,2.888769
28.999031,-19.595369,1.008678,-0.001866,2.882032
30.988729,-16.480400,1.010672,-0.001438,2.879534
34.990238,-5.528003,1.018046,0.000258,2.873870
32.973141,-12.554328,1.013832,-0.000885,2.873488
34.990238,-6.509241,1.019656,0.000001,2.864963
34.990238,-7.498059,1.018745,-0.000136,2.846882
34.990246,-4.502323,1.003732,0.000967,2.845149
32.973141,-13.544339,1.012913,-0.000987,2.841547
30.988729,-17.427807,1.009974,-0.001512,2.840743
26.971287,0.500000,0.765986,-0.002206,2.839530
26.971287,-0.499999,0.763110,0.002376,2.828871
34.990238,-8.524320,1.017676,-0.000270,2.825808
32.973141,-14.488797,1.012083,-0.001080,2.810094
34.990238,-9.506057,1.016647,-0.000392,2.803883
30.988729,-18.498339,1.009241,-0.001590,2.796457
34.990238,-10.487569,1.015633,-0.000508,2.780411
32.973141,-15.468817,1.011276,-0.001169,2.776607
32.973125,2.486060,0.916665,-0.003661,2.772189
32.973125,-2.483023,0.915931,0.003397,2.769988
34.990250,-3.495990,0.969602,0.002133,2.757342
34.990238,-11.531277,1.014584,-0.000626,2.753925
34.990250,3.504131,0.968407,-0.002192,2.753881
30.988729,-19.595379,1.008543,-0.001661,2.750745
32.973141,-16.480400,1.010493,-0.001256,2.741264
34.990238,-12.554325,1.013599,-0.000735,2.726614
30.988741,1.471829,0.845715,-0.004288,2.726065
36.986797,-5.528002,1.017067,0.000462,2.719603
36.986801,-6.509238,1.019273,0.000142,2.714066
30.988741,-1.471531,0.840134,0.004010,2.708073
32.973141,-17.427807,1.009808,-0.001331,2.707587
34.990238,-13.544338,1.012693,-0.000835,2.699061
36.986801,-7.498059,1.018444,-0.000016,2.698640
36.986801,-4.502321,1.001861,0.001176,2.688853
36.986801,-8.524320,1.017396,-0.000156,2.680434
34.990238,-14.488796,1.011877,-0.000925,2.671880
32.973141,-18.498339,1.009086,-0.001410,2.669005
28.999054,0.499999,0.773958,-0.002100,2.668521
36.986801,-9.506058,1.016379,-0.000278,2.661456
28.999054,-0.499999,0.771284,0.002136,2.659303
34.990238,-15.468817,1.011080,-0.001013,2.642861
36.986801,-10.487571,1.015380,-0.000393,2.641128
32.973141,-19.595379,1.008404,-0.001484,2.629046
36.986801,-11.531277,1.014345,-0.000507,2.618160
34.990238,-16.480398,1.010309,-0.001098,2.612163
34.990257,2.486060,0.914329,-0.003421,2.606544
34.990257,-2.483025,0.913872,0.003399,2.605256
36.986805,-3.495991,0.966935,0.002273,2.602676
36.986805,3.504132,0.966064,-0.002137,2.600278
36.986805,-12.554323,1.013373,-0.000613,2.594444
34.990238,-17.427807,1.009637,-0.001173,2.582840
39.005447,-5.528002,1.016071,0.000486,2.579174
39.005444,-6.509238,1.018866,0.000187,2.576483
36.986805,-13.544339,1.012482,-0.000710,2.570485
32.973114,1.471829,0.847060,-0.004113,2.566415
39.005444,-7.498059,1.018142,0.000045,2.563323
32.973114,-1.471531,0.841929,0.003605,2.550864
34.990238,-18.498335,1.008932,-0.001252,2.549155
39.005447,-8.524320,1.017114,-0.000082,2.547496
39.005451,-4.502321,1.000046,0.001180,2.546954
36.986805,-14.488796,1.011676,-0.000797,2.546801
39.005451,-9.506058,1.016121,-0.000197,2.530994
36.986805,-15.468820,1.010890,-0.000883,2.521475
30.988739,0.500000,0.781139,-0.002070,2.520398
34.990238,-19.595385,1.008260,-0.001327,2.514143
39.005451,-10.487571,1.015134,-0.000305,2.513281
30.988739,-0.500000,0.778736,0.001729,2.512643
36.986805,-16.480400,1.010131,-0.000966,2.494625
39.005451,-11.531277,1.014114,-0.000414,2.493258
39.005455,-12.554323,1.013153,-0.000515,2.472551
36.986805,-17.427807,1.009470,-0.001040,2.468924
39.005451,-3.495991,0.964493,0.002220,2.462847
36.986805,2.486060,0.912476,-0.003222,2.461492
39.005451,3.504132,0.963840,-0.002122,2.461133
36.986805,-2.483027,0.912102,0.003408,2.460500
40.988270,-5.528009,1.015153,0.000481,2.454470
40.988274,-6.509232,1.018498,0.000191,2.454099
39.005455,-13.544339,1.012274,-0.000607,2.451613
40.988274,-7.498060,1.017882,0.000068,2.442811
36.986805,-18.498331,1.008774,-0.001118,2.439322
39.005463,-14.488796,1.011477,-0.000691,2.430881
40.988274,-8.524323,1.016872,-0.000042,2.428913
34.990257,1.471828,0.848341,-0.003709,2.422389
40.988262,-4.502319,0.998329,0.001146,2.421084
40.988277,-9.506057,1.015886,-0.000144,2.414397
34.990257,-1.471532,0.844065,0.003476,2.410176
39.005455,-15.468820,1.010704,-0.000774,2.408686
36.986805,-19.595387,1.008117,-0.001193,2.408485
40.988277,-10.487573,1.014911,-0.000243,2.398822
32.973106,0.500000,0.787671,-0.002123,2.388562
39.005463,-16.480400,1.009956,-0.000855,2.385113
32.973106,-0.500000,0.785542,0.001357,2.382102
40.988277,-11.531278,1.013900,-0.000344,2.381196
40.988281,-12.554323,1.012952,-0.000439,2.362967
39.005463,-17.427807,1.009302,-0.000927,2.362499
40.988281,-13.544338,1.012079,-0.000527,2.344505
42.982166,-6.509234,1.018142,0.000206,2.342050
42.982159,-5.528006,1.014257,0.000490,2.340439
40.988255,-3.495992,0.962297,0.002140,2.339250
40.988255,3.504132,0.961807,-0.002111,2.338020
39.005455,-18.498331,1.008621,-0.001004,2.336415
42.982166,-7.498060,1.017663,0.000087,2.332416
39.005455,2.486060,0.911063,-0.003032,2.331015
39.005455,-2.483027,0.910665,0.003178,2.330010
40.988285,-14.488795,1.011293,-0.000607,2.326216
42.982166,-8.524322,1.016651,-0.000013,2.320099
39.005463,-19.595387,1.007970,-0.001077,2.309160
42.982166,-9.506058,1.015669,-0.000107,2.307248
40.988281,-15.468822,1.010528,-0.000687,2.306610
42.982155,-4.502320,0.996559,0.001169,2.305928
36.986801,1.471827,0.849746,-0.003315,2.295631
42.982166,-10.487573,1.014701,-0.000198,2.293465
36.986801,-1.471533,0.846325,0.003345,2.286391
40.988285,-16.480400,1.009791,-0.000765,2.285764
42.982166,-11.531278,1.013700,-0.000292,2.277871
34.990257,0.500000,0.793774,-0.001889,2.268332
40.988285,-17.427807,1.009144,-0.000834,2.265728
34.990257,-0.500000,0.791894,0.001276,2.262957
42.982166,-12.554323,1.012759,-0.000382,2.261729
42.982166,-13.544339,1.011895,-0.000465,2.245378
40.988281,-18.498325,1.008467,-0.000909,2.242574
44.981125,-6.509230,1.017766,0.000232,2.239326
44.981121,-5.528008,1.013357,0.000531,2.236026
44.981125,-7.498060,1.017448,0.000106,2.231158
42.982166,-14.488795,1.011115,-0.000541,2.229165
42.982147,-3.495992,0.960091,0.002189,2.226351
42.982147,3.504132,0.959871,-0.002060,2.225806
44.981121,-8.524325,1.016444,0.000009,2.220196
40.988285,-19.595387,1.007833,-0.000981,2.218361
40.988247,2.486058,0.910188,-0.002858,2.216546
40.988247,-2.483027,0.909593,0.003036,2.215108
42.982166,-15.468821,1.010359,-0.000616,2.211772
44.981121,-9.506058,1.015466,-0.000080,2.208753
44.981117,-4.502319,0.994813,0.001188,2.200628
44.981121,-10.487573,1.014506,-0.000166,2.196493
42.982166,-16.480400,1.009626,-0.000691,2.193250
44.981121,-11.531279,1.013511,-0.000254,2.182612
39.005482,1.471827,0.851271,-0.003006,2.180902
42.982166,-17.427807,1.008989,-0.000758,2.175437
39.005482,-1.471533,0.848563,0.002966,2.173963
44.981121,-12.554324,1.012578,-0.000338,2.168251
36.986794,0.500000,0.799264,-0.001589,2.160753
36.986794,-0.500000,0.797692,0.001340,2.156499
42.982166,-18.498327,1.008323,-0.000830,2.154826
44.981121,-13.544339,1.011719,-0.000417,2.153691
46.982620,-6.509232,1.017379,0.000235,2.144949
46.982628,-5.528009,1.012459,0.000532,2.140201
44.981113,-14.488794,1.010947,-0.000489,2.139253
46.982620,-7.498060,1.017238,0.000109,2.138079
42.982166,-19.595387,1.007686,-0.000900,2.133204
46.982620,-8.524323,1.016248,0.000018,2.128283
44.981121,-15.468824,1.010198,-0.000560,2.123752
44.981117,-3.495992,0.958089,0.002140,2.123582
44.981117,3.504133,0.958096,-0.002000,2.123567
46.982616,-9.506057,1.015279,-0.000065,2.118049
42.982140,2.486059,0.909432,-0.002751,2.112315
42.982140,-2.483027,0.908873,0.002960,2.111028
44.981113,-16.480400,1.009472,-0.000632,2.107231
46.982616,-10.487573,1.014320,-0.000146,2.107069
46.982639,-4.502319,0.993142,0.001160,2.104212
46.982616,-11.531278,1.013333,-0.000229,2.094657
44.981113,-17.427807,1.008840,-0.000696,2.091326
46.982613,-12.554323,1.012405,-0.000308,2.081810
40.988247,1.471825,0.852699,-0.002765,2.079021
40.988247,-1.471534,0.850701,0.002751,2.074150
44.981121,-18.498327,1.008182,-0.000765,2.072902
46.982613,-13.544338,1.011553,-0.000382,2.068787
39.005493,0.500000,0.804193,-0.001444,2.061577
39.005493,-0.500000,0.803038,0.001157,2.058615
46.982605,-14.488795,1.010787,-0.000450,2.055869
49.040997,-6.509230,1.016982,0.000221,2.055710
44.981113,-19.595387,1.007554,-0.000833,2.053550
49.040997,-7.498060,1.017032,0.000099,2.050018
49.041000,-5.528008,1.011577,0.000505,2.049735
46.982613,-15.468822,1.010041,-0.000518,2.041988
49.040997,-8.524325,1.016058,0.000015,2.041248
49.041000,-9.506058,1.015095,-0.000061,2.032067
46.982647,3.504132,0.956581,-0.001996,2.030395
46.982647,-3.495992,0.956246,0.002078,2.029711
46.982605,-16.480400,1.009322,-0.000586,2.027188
49.041000,-10.487573,1.014144,-0.000137,2.022226
44.981113,2.486057,0.908691,-0.002596,2.017091
44.981113,-2.483028,0.908353,0.002795,2.016351
49.041004,-4.502319,0.991491,0.001101,2.013294
46.982605,-17.427807,1.008699,-0.000647,2.012938
49.041000,-11.531279,1.013161,-0.000214,2.011098
49.041000,-12.554324,1.012237,-0.000288,1.999582
46.982613,-18.498325,1.008047,-0.000713,1.996405
49.041000,-13.544339,1.011392,-0.000358,1.987917
42.982170,1.471826,0.854221,-0.002591,1.986230
42.982170,-1.471533,0.852747,0.002594,1.982803
46.982605,-19.595387,1.007434,-0.000778,1.979038
49.041004,-14.488794,1.010630,-0.000422,1.976336
51.034508,-6.509230,1.016598,0.000207,1.975975
40.988247,0.500000,0.808465,-0.001294,1.972286
51.034508,-7.498060,1.016840,0.000084,1.971293
40.988247,-0.500000,0.807793,0.001052,1.970647
51.034508,-5.528008,1.010767,0.000486,1.969038
49.041000,-15.468824,1.009892,-0.000486,1.963899
51.034508,-8.524321,1.015892,0.000006,1.963397
51.034508,-9.506059,1.014933,-0.000066,1.955093
49.041004,-16.480400,1.009180,-0.000550,1.950631
51.034508,-10.487572,1.013982,-0.000136,1.946186
49.041004,3.504133,0.955211,-0.001988,1.942830
49.041004,-3.495992,0.954482,0.001944,1.941371
49.041004,-17.427807,1.008559,-0.000608,1.937837
51.034508,-11.531280,1.013003,-0.000209,1.936129
51.034504,-4.502320,0.989985,0.001057,1.932330
46.982655,2.486058,0.908099,-0.002493,1.930146
46.982655,-2.483027,0.907969,0.002674,1.929878
51.034504,-12.554325,1.012086,-0.000279,1.925729
49.041000,-18.498327,1.007911,-0.000671,1.922988
51.034504,-13.544339,1.011244,-0.000345,1.915190
49.041004,-19.595387,1.007299,-0.000732,1.907367
51.034504,-14.488795,1.010489,-0.000405,1.904737
53.017651,-6.509230,1.016211,0.000192,1.902456
44.981106,1.471824,0.855581,-0.002450,1.901080
44.981106,-1.471534,0.854825,0.002414,1.899400
53.017651,-7.498060,1.016658,0.000069,1.898690
53.017654,-5.528008,1.009974,0.000475,1.894706
51.034504,-15.468826,1.009754,-0.000466,1.893502
53.017643,-8.524321,1.015735,-0.000008,1.891551
42.982182,0.500000,0.812533,-0.001242,1.890268
42.982182,-0.500000,0.812196,0.000977,1.889485
53.017635,-9.506059,1.014776,-0.000077,1.883990
51.034504,-16.480400,1.009047,-0.000526,1.881514
53.017635,-10.487572,1.013831,-0.000144,1.875902
51.034504,-17.427807,1.008431,-0.000581,1.869951
53.017635,-11.531280,1.012856,-0.000213,1.866769
51.034500,3.504132,0.953936,-0.001933,1.864812
51.034500,-3.495992,0.952944,0.001841,1.862892
53.017662,-4.502320,0.988514,0.001071,1.857813
53.017624,-12.554325,1.011944,-0.000279,1.857331
51.034504,-18.498329,1.007790,-0.000641,1.856528
49.041008,2.486057,0.907626,-0.002460,1.848382
49.041008,-2.483028,0.907620,0.002481,1.848375
53.017624,-13.544339,1.011106,-0.000341,1.847769
51.034504,-19.595388,1.007180,-0.000699,1.842386
53.017609,-14.488795,1.010353,-0.000398,1.838284
54.985279,-6.509230,1.015815,0.000187,1.834620
54.985279,-7.498060,1.016472,0.000054,1.831673
53.017624,-15.468826,1.009624,-0.000455,1.828096
54.985275,-5.528007,1.009133,0.000470,1.826074
54.985279,-8.524316,1.015578,-0.000029,1.825196
46.982670,1.471825,0.856850,-0.002327,1.822870
46.982670,-1.471534,0.856725,0.002309,1.822605
54.985275,-9.506060,1.014630,-0.000097,1.818302
53.017609,-16.480400,1.008920,-0.000512,1.817220
44.981102,0.500000,0.816380,-0.001255,1.814829
44.981102,-0.500000,0.816361,0.000862,1.814788
54.985275,-10.487572,1.013690,-0.000161,1.810921
53.017609,-17.427807,1.008311,-0.000564,1.806732
54.985275,-11.531281,1.012720,-0.000226,1.802589
53.017624,-18.498329,1.007673,-0.000620,1.794543
54.985275,-12.554328,1.011811,-0.000288,1.793983
53.017666,3.504132,0.952694,-0.001805,1.793028
53.017666,-3.495992,0.951606,0.001811,1.790998
54.985268,-4.502322,0.987047,0.001070,1.789124
54.985275,-13.544338,1.010979,-0.000346,1.785271
53.017609,-19.595388,1.007070,-0.000675,1.781701
54.985275,-14.488795,1.010229,-0.000399,1.776628
51.034496,-2.483027,0.907243,0.002324,1.775611
51.034496,2.486057,0.907214,-0.002366,1.775550
56.999798,-6.509230,1.015427,0.000120,1.769953
56.999798,-7.498060,1.016278,-0.000001,1.767722
54.985275,-15.468827,1.009505,-0.000453,1.767349
56.999798,-8.524321,1.015434,-0.000070,1.761876
56.999813,-5.528008,1.008340,0.000379,1.760761
54.985275,-16.480396,1.008807,-0.000506,1.757444
56.999798,-9.506059,1.014489,-0.000130,1.755565
49.040993,-1.471534,0.858613,0.002143,1.750024
49.040993,1.471824,0.858064,-0.002279,1.748906
56.999798,-10.487572,1.013553,-0.000188,1.748815
54.985275,-17.427807,1.008199,-0.000555,1.747885
46.982677,-0.500000,0.820226,0.000865,1.745707
46.982677,0.500000,0.820092,-0.001142,1.745423
56.999798,-11.531280,1.012590,-0.000248,1.741207
54.985275,-18.498331,1.007564,-0.000607,1.736774
56.999802,-12.554325,1.011684,-0.000305,1.733345
54.985260,3.504131,0.951510,-0.001724,1.726981
56.999802,-13.544339,1.010854,-0.000358,1.725392
54.985260,-3.495992,0.950461,0.001744,1.725094
54.985275,-19.595390,1.006968,-0.000659,1.725071
56.999821,-4.502320,0.985664,0.000915,1.723872
56.999805,-14.488795,1.010110,-0.000408,1.717511
56.999802,-15.468826,1.009385,-0.000458,1.709041
53.017677,2.486057,0.906965,-0.002192,1.708811
53.017677,-2.483027,0.906898,0.002221,1.708690
56.999805,-16.480400,1.008695,-0.000508,1.700014
56.999805,-17.427807,1.008091,-0.000553,1.691299
51.034512,-1.471532,0.860448,0.001977,1.685317
51.034512,1.471824,0.859236,-0.002163,1.682942
56.999802,-18.498329,1.007462,-0.000603,1.681168
49.040985,-0.500000,0.823972,0.000760,1.680084
49.040985,0.500000,0.823796,-0.001133,1.679725
56.999805,-19.595388,1.006868,-0.000651,1.670485
56.999828,3.504132,0.950346,-0.001535,1.664139
56.999828,-3.495992,0.949399,0.001502,1.662496
54.985252,2.486057,0.906834,-0.002034,1.647552
54.985252,-2.483027,0.906716,0.002112,1.647341
53.017658,-1.471532,0.862100,0.001880,1.625439
53.017658,1.471824,0.860469,-0.001944,1.622364
51.034512,-0.500000,0.827349,0.000710,1.621079
51.034512,0.500000,0.827198,-0.001048,1.620783
56.999828,2.486057,0.906886,-0.001796,1.589526
56.999828,-2.483027,0.906452,0.001882,1.588768
54.985237,-1.471531,0.863657,0.001774,1.570148
54.985237,1.471825,0.861609,-0.001760,1.566425
53.017654,-0.500000,0.830394,0.000748,1.566191
53.017654,0.500000,0.830371,-0.000876,1.566147
56.999817,-1.471532,0.864970,0.001696,1.516994
54.985229,0.500000,0.833224,-0.000817,1.515298
54.985229,-0.500000,0.833202,0.000692,1.515258
56.999817,1.471824,0.862696,-0.001528,1.513005
56.999813,-0.500000,0.835962,0.000768,1.466548
56.999813,0.500000,0.835849,-0.000623,1.466350
======================================================
                      TASK 3                          
======================================================
threshold,points,percentage
0.500000,0,0.000000
0.600000,98,0.038153
0.700000,4436,1.727018
0.800000,21085,8.208784
0.900000,66306,25.814163
1.000000,109437,42.605865
1.100000,256859,100.000000
======================================================
                    TASK 4.1                          
======================================================
x,y_h
10.028000,-4.187200
14.958000,-4.819600
20.011999,-5.430400
24.993000,5.634300
29.980000,5.921400
34.987000,-6.197700
39.986000,-6.610100
44.979000,6.633000
49.999001,6.739500
54.983002,6.956200
60.005001,7.066400
65.024002,7.290400
======================================================
                    TASK 4.2                          
======================================================
                                   *
                                 *
                                *
                              *
                             *
                             *
                        *
                      *
                   *
                 *
           *
    *
III
III
III
III
III
    *
           *
                 *
                   *
                      *
                        *
                             *
                             *
                              *
                                *
                                 *
                                   *
======================================================
============================================
src/main.c
16:45:21_Tuesday_29_August_2017
============================================
/***************************************************************************
 *
 *   File        : main.c
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <sys/time.h>
#include <string.h>
#include "tasks.h"

/* My BST Library, used for building and searching a balanced BST */
#include "data_handler.h" 

#define NUM_ARGS 3
#define INPUT_INSTRUCTIONS "USAGE EXAMPLE: ./flow flow_data.csv 24"

typedef struct timeval myTime_t;
myTime_t timer_start();
double timer_stop(myTime_t start);

int main(int argc, char *argv[]) {

	// Parse Command Line Arguments
	if (argc != NUM_ARGS) {
		printf(INPUT_INSTRUCTIONS);
		exit(EXIT_FAILURE);
	}
	char* flowFileName = argv[1];
	int gridResolution = atoi(argv[2]);

	// Generate bst
	bst_t* bst = parseFlowFile(flowFileName);
	
	// Task 1: Find the maximum velocity difference
	myTime_t task1_time = timer_start();
	maxveldiff(bst);
	printf("TASK1: %.2lf milliseconds\n", timer_stop(task1_time));

	// Task 2: Coarser Grid
	myTime_t task2_time = timer_start();
	coarsegrid(bst, gridResolution);
	printf("TASK2: %.2lf milliseconds\n", timer_stop(task2_time));

	// Task 3: Statistics
	myTime_t task3_time = timer_start();
	velstat(bst);
	printf("TASK3: %.2lf milliseconds\n", timer_stop(task3_time));

	// Task 4: Wake height and visualisation
	myTime_t task4_time = timer_start();
	wakevis(bst);
	printf("TASK4: %.2lf milliseconds\n", timer_stop(task4_time));

	// free bst
	bst_freeTree(bst);

	return EXIT_SUCCESS;
}

myTime_t timer_start() {
	myTime_t start;
	gettimeofday(&start, NULL);
	return start;
}

double timer_stop(myTime_t start) {
	myTime_t stop;
	gettimeofday(&stop, NULL);
	double elapsed_ms = (stop.tv_sec - start.tv_sec) * 1000.0;
	elapsed_ms += (stop.tv_usec - start.tv_usec) / 1000.0;
	return elapsed_ms;
}
============================================
src/tasks.h
16:45:21_Tuesday_29_August_2017
============================================
/***************************************************************************
 *
 *   File        : tasks.h
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/

#include "data_handler.h"

#ifndef TASKS_H
#define TASKS_H

#define T1_CSV "task1.csv"
#define T2_CSV "task2.csv"
#define T3_CSV "task3.csv"
#define T4_1_CSV "task4_1.csv"
#define T4_2_CSV "task4_2.csv"
#define FILE_REWRITE "w"

#define BST_X 0
#define BST_Y 1
#define BST_U 2
#define BST_V 3
#define BST_DIM 4

#define MVD_THRESH 20

#define T2_HEADER "x,y,u,v,S\n"
#define T2_SCORE(x,y,u,v) 100*(sqrt(pow(u,2)+pow(v,2))/sqrt(pow(x,2)+pow(y,2)))
#define GRID_X_MIN 10
#define GRID_X_MAX 70
#define GRID_Y_MIN -20
#define GRID_Y_MAX 20

#define T3_HEADER "threshold,points,percentage\n"
#define T3_INIT_THRESH 0.5
#define T3_THRESH_INTERVAL 0.1
#define T3_PERCENT_END 100.0
#define PERCENT(numer, denom) 100.0*((float)numer/(float)denom)

#define T4_HEADER "x,y_h\n"
#define T4_NUM_Y 12
#define T4_INIT_X 10
#define T4_X_INTERVAL 5
#define TOLERANCE 0.05
#define SPACING(y) ceil(10.0 * fabs(y))

// Cell data type for task 2
typedef struct {
    results_t* points;
    float* av;
    float score;
} cell_t;

// Filter functions used during searching in Task 1
int mvdMaxU(float* d, results_t* res);
int mvdMinU(float* d, results_t* res);
int mvdMaxV(float* d, results_t* res);
int mvdMinV(float* d, results_t* res);

// Used in Task 2
cell_t* generateCell(bst_t* bst, resultsFilter_t* bounds);
void destroyCells(cell_t* cell[], int n);
void destroyCell(cell_t* cell);
void printTask2(cell_t* cells[], int n);
int cellCmp(const void* a, const void* b);

// Used in Task 4
float* getYs_t4(bst_t* bst);

// Task functions
void maxveldiff(bst_t* bst);
void coarsegrid(bst_t* bst, int resolution);
void velstat(bst_t* bst);
void wakevis(bst_t* bst);

#endif
============================================
src/data_handler.h
16:45:21_Tuesday_29_August_2017
============================================
/***************************************************************************
 *
 *   File        : data_handler.h
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/
#include <stdio.h>

#ifndef DATA_HANDLER_H
#define DATA_HANDLER_H

#define FILE_READ "r"
#define PARSE_DONE 1
#define CSV_NEWLINE '\n'
#define CSV_COMMA ','
#define BST_INDEX 0
#define BST_BALANCE_THRESH 2
#define RESULTS_LEN 128
#define MAX(a, b) (((a) > (b)) ? (a) : (b))
#define EPS 0.00001

/* node type */
// Note: Each node is part of any number of binary trees, a tree is formed for
// each of the data entries in the csv, so that in the case of this assignment, 
// there would be trees for x,y,u and v
typedef struct NodeStruct node_t;
struct NodeStruct {
	float* d; // data
	int* depth_L; // depth of the left subtree
	int* depth_R; // depth of the right subtree
	node_t** parent; // Pointers to parents
	node_t** left; // Pointers to left subtrees
	node_t** right; // Pointers to right subtrees
};

/* bst type */
typedef struct {
	int numNodes;
	int dim; // dimension of the tree, eg: 4 for {'x','y','u','v'}
	node_t** root;
	char* key; // In this case the key is: {'x','y','u','v'}
} bst_t;

/* Results type */
// Note: Check function returns 1 when a new data point should be inserted into
// the results. I also use the check function to do other stuff, like keep track
// of the maximum value in the results.

typedef struct { // Used to define a search
	float lo, hi;
} resultsFilter_t;

typedef struct ResultsStruct results_t;
struct ResultsStruct {
	int arrLen, numEl;
	int dim;
	resultsFilter_t* filter;
	int (*check)(float*, results_t*);
	float** arr; // results of the search appear in this array
};

// parse flow file
bst_t* parseFlowFile(char* filename);
bst_t* parseFlowFileFirstLine(FILE* fp);
int parseFlowFileDataLine(bst_t* bst, FILE* fp);

// build a tree
bst_t* bst_newTree(int dim, char* key);
void bst_insertData(bst_t* bst, float* data);
int bst_freeTree(bst_t* bst);

// print data
void bst_printKey(bst_t* bst, FILE* stream);
void bst_printData(int dim, float* data, FILE* stream);
int bst_printTree(bst_t* bst, int dataIndex, FILE* stream);

// search the tree
results_t* res_search(
	bst_t* bst, resultsFilter_t* filter, int (*check)(float*, results_t*));

void res_free(results_t* res);
int res_filterBoundExclude(float* d, results_t* res);
int res_filterBoundInclude(float* d, results_t* res);

#endif============================================
src/data_handler.c
16:45:21_Tuesday_29_August_2017
============================================
/***************************************************************************
 *
 *   File        : data_handler.c
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <float.h>
#include <string.h>
#include <assert.h>
#include "data_handler.h"

/* * * * * * * * * * * * * * * * * * * * * * *  PRIVATE FUNCTION DECLARATIONS */
// Private functions don't need to be visible to code outside this file

// Funcions dealing with nodes rather than data
static node_t* bst_newNode(int dim, float* data);
static void bst_freeNode(node_t* node);

// BST balancing functions
static void bst_balance( bst_t* bst, node_t* node_a, int dataIndex);
static node_t* bst_leftOuterRot(bst_t* bst, node_t* node_a, int dataIndex);
static node_t* bst_rightOuterRot(bst_t* bst, node_t* node_a, int dataIndex);
static node_t* bst_leftInnerRot(bst_t* bst, node_t* node_a, int dataIndex);
static node_t* bst_rightInnerRot(bst_t* bst, node_t* node_a, int dataIndex);
static int node_maxDepth(node_t* node, int dataIndex);
static void fixParentDepth(bst_t* bst, node_t* node_a, int dataIndex);

// Recursive helper functions
static int bst_printTree_Rec( node_t* n, int dataIndex, int dim, FILE* stream);
static int bst_freeTree_Rec(bst_t* bst, node_t* root, int dataIndex);
static void bst_insertNode_Rec(bst_t* bst, node_t* root, node_t* newNode, int dataIndex);

// Helper search functions
static void bst_search_Rec(node_t* node, results_t *f, int t);
static void res_insert(results_t* res, float* d);




/* * * * * * * * * * * * * * * * * * * * * * * * * * * * *  PARSING FUNCTIONS */

// Returns bst containing data from the flow file
bst_t* parseFlowFile(char *filename) {

	assert(filename!=NULL);
	
	FILE* fp = fopen(filename, FILE_READ);
	assert(fp != NULL);
	
	bst_t* bst = parseFlowFileFirstLine(fp);
	while (parseFlowFileDataLine(bst, fp) != PARSE_DONE) {
	}

	fclose(fp);

	return bst;
}

// Parses first line of flow file to get:
//  1. key (eg: {'x','y','u','v'}) and
//  2. number of dimensions (eg: 4 data entries for each line in the csv)
// Uses the key and number of dimensions to generate an empty bst
bst_t* parseFlowFileFirstLine(FILE* fp) {
	
	assert(fp!=NULL);

	char* key = (char* )malloc( sizeof(char) );
	assert(key != NULL);

	char tmpc;
	int i = 0;
	while (1) {

		tmpc = fgetc(fp);
		if (tmpc == CSV_COMMA) { continue; }
		if (tmpc == CSV_NEWLINE) { break; }

		key = (char*)realloc( key, (i+2) * sizeof(char) );
		assert(key != NULL);
		key[i] = tmpc;
		i++;
	}

	return bst_newTree(i, key);
}

// Parses a data entry from flow file, inserts it into bst
int parseFlowFileDataLine(bst_t* bst, FILE* fp) {

	assert(bst!=NULL);
	assert(fp!=NULL);
	
	// Store the data in an array d
	float* data = (float*)malloc(bst->dim*sizeof(float));
	assert(data != NULL);
	
	// Read the line into array d
	int i = 0, read=0;
	for (i=0; i < bst->dim; i++) {
		read += fscanf(fp, "%f,", &(data[i]) );
	}

	// Decide whether to insert data, finish parsing, or detect an error
	char endCheck = fgetc(fp);
	if ( read==(bst->dim) && endCheck == CSV_NEWLINE) {
		bst_insertData(bst, data);
		return !PARSE_DONE;
	} else if ( endCheck == EOF) {
		free(data);
		return PARSE_DONE;
	} else {
		printf("ERROR: File parsing failed, exiting...");
		exit(EXIT_FAILURE);
	}
}




/* * * * * * * * * * * * * * * * * * * * * * *  PUBLIC BST AND DATA FUNCTIONS */

// Generate a new empty bst
bst_t* bst_newTree(int dim, char* key) {

	assert(key!=NULL);
	
	bst_t* bst = (bst_t*)malloc(sizeof(bst_t));
	assert(bst != NULL);

	bst->root = (node_t**)calloc( dim , sizeof(node_t*) );
	assert(bst->root != NULL);

	bst->numNodes = 0;
	bst->dim = dim;
	bst->key = key;

	return bst;
}

// Frees memory associated with a tree, including the data
int bst_freeTree(bst_t* bst) {

	assert(bst!=NULL);

	int freed = bst_freeTree_Rec(bst, bst->root[BST_INDEX], BST_INDEX);
	assert(bst->numNodes == 0);
	free(bst->root);
	free(bst->key);
	free(bst);

	return freed;
}

// Inserts a data array into the bst as a node
void bst_insertData(bst_t* bst, float* data) {
	
	assert(bst!=NULL);
	assert(data!=NULL);

	node_t* newNode = bst_newNode(bst->dim, data);
	
	int i=0;
	for (i=0; i<bst->dim; i++) {
		if (bst->root[i] == NULL) {
			bst->root[i] = newNode;
		} else {
			bst_insertNode_Rec(bst, bst->root[i],newNode,i);
		}
	}
	bst->numNodes++;
}

// Prints the key of the bst 
void bst_printKey(bst_t* bst, FILE* stream) {
	
	assert(bst!=NULL);

	int i = 0;
	for (i=0; i < bst->dim; i++) {
		fprintf(stream, "%c", bst->key[i] );
		if (i < bst->dim-1) { fprintf(stream, ","); }
	}
	fprintf(stream, "\n");
}

// Prints all of the items in order of low to high
int bst_printTree(bst_t* bst, int dataIndex, FILE* stream) {

	assert(bst!=NULL);
	assert(dataIndex < bst->dim);

	bst_printKey(bst, stream);	
	return bst_printTree_Rec(bst->root[dataIndex], dataIndex, bst->dim, stream);
}

// Prints a data entry
void bst_printData(int dim, float* data, FILE* stream) {

	assert(data!=NULL);

	int i = 0;
	for (i=0; i < dim; i++) {
		fprintf(stream, "%.6f", data[i] );
		if (i < dim-1) { fprintf(stream, ",");}
	}
	fprintf(stream, "\n");
}

// Searches a bst for data entries beween lo and hi
// The check function must return 1 or 0 to insert or not insert an item
// The check function can also modify the results since it has access to them
results_t* res_search(
	bst_t* bst, resultsFilter_t* filter, int (*check)(float*, results_t*) ) {

	assert(check!=NULL);
	assert(filter!=NULL);
	assert(bst != NULL);

	float** arr = (float**)calloc(RESULTS_LEN, sizeof(float*));
	assert(arr!=NULL);

	results_t* res = (results_t*)malloc(sizeof(results_t));
	assert(res!=NULL);

	res->arrLen = RESULTS_LEN;
	res->numEl = 0;
	res->dim = bst->dim;
	res->filter = filter;
	res->check = check;
	res->arr = arr;

	// Determine best filter to apply (the one with the most narrow bounds)
	float minDiff=FLT_MAX;
	int i=0, t=0;
	for (i=0; i<bst->dim; i++) {
		if ((res->filter[i].hi - res->filter[i].lo) < minDiff ) {
			minDiff = res->filter[i].hi - res->filter[i].lo;
			t = i;
		}
	}
	bst_search_Rec(bst->root[t],res,t);

	return res;
}

// Free a results structure
void res_free(results_t* res) {
	free(res->arr);
	free(res);
}




/* * * * * * * * * * * * * * * * * * * * * * * * * * * * *  PRIVATE FUNCTIONS */

// Generates a new node
static node_t* bst_newNode(int dim, float* data) {
	
	assert(data != NULL);
	assert(dim>0);

	node_t* newNode = (node_t*)malloc(sizeof(node_t));
	newNode->d = data;
	newNode->depth_R = (int*)calloc(dim, sizeof(int*));
	newNode->depth_L = (int*)calloc(dim, sizeof(int*));
	newNode->left = (node_t**)calloc(dim, sizeof(node_t*));
	newNode->right = (node_t**)calloc(dim, sizeof(node_t*));
	newNode->parent = (node_t**)calloc(dim, sizeof(node_t*));

	assert(newNode != NULL);
	assert(newNode->depth_R != NULL);
	assert(newNode->depth_L != NULL);
	assert(newNode->left != NULL);
	assert(newNode->right != NULL);
	assert(newNode->parent != NULL);

	return newNode;
}

// Frees a node
static void bst_freeNode(node_t* node) {

	assert(node != NULL);
	assert(node->left != NULL);
	assert(node->right != NULL);
	assert(node->d != NULL);

	free(node->d);
	free(node->depth_R);
	free(node->depth_L);
	free(node->right);
	free(node->left);
	free(node->parent);
	free(node);
}

// Iteratively insert a node into a bst
static void bst_insertNode_Rec(bst_t* bst, node_t* root, node_t* newNode, int dataIndex) {
	
	assert(newNode != NULL);
	assert(root != NULL);
	assert(bst != NULL);

	if (newNode->d[dataIndex] < root->d[dataIndex]) {

		root->depth_L[dataIndex]++;
		if (root->left[dataIndex] == NULL) {
			root->left[dataIndex] = newNode;
			newNode->parent[dataIndex] = root;
			bst_balance(bst, root, dataIndex);
		} else {
			bst_insertNode_Rec(bst, root->left[dataIndex],newNode,dataIndex);
		}
	} else {
		root->depth_R[dataIndex]++;
		if (root->right[dataIndex] == NULL) {
			root->right[dataIndex] = newNode;
			newNode->parent[dataIndex] = root;
		} else {
			bst_insertNode_Rec(bst, root->right[dataIndex],newNode,dataIndex);
		}
	}
	bst_balance(bst, root, dataIndex);
}

// Recursively print tree (in order traverse), returns number of items printed
static int bst_printTree_Rec(node_t* n, int dataIndex, int dim, FILE* stream) {

	assert(dataIndex < dim);

	int numPrinted = 0;

	if (n!=NULL) {

		node_t* left = n->left[dataIndex];
		node_t* right = n->right[dataIndex];
		numPrinted=1;

		numPrinted += bst_printTree_Rec(left, dataIndex, dim, stream);
		bst_printData(dim, n->d, stream);
		numPrinted += bst_printTree_Rec(right, dataIndex, dim, stream);
	}
	return numPrinted;
}

// Recursively free a tree (post order traverse), returns number of items freed
static int bst_freeTree_Rec(bst_t* bst, node_t* root, int dataIndex) {

	int numFreed = 0;
	if (root!=NULL) {
		numFreed++;
		numFreed += bst_freeTree_Rec(bst, root->left[dataIndex], dataIndex);
		numFreed += bst_freeTree_Rec(bst, root->right[dataIndex], dataIndex);
		bst_freeNode(root);
		bst->numNodes--;
	}
	return numFreed;
}

// Recursively search the tree
static void bst_search_Rec(node_t* node, results_t *f, int t) {
	
	assert(f!=NULL);
	assert(t < f->dim);

	if ( node != NULL ) {

		int aboveUpper=0, belowLower=0, inBetween=0;
		
		aboveUpper = node->d[t] > (f->filter[t].hi + EPS);
		belowLower = node->d[t] < (f->filter[t].lo - EPS);
		inBetween = (aboveUpper == 0) && (belowLower == 0);

		if ( aboveUpper ) {
			bst_search_Rec(node->left[t],  f, t);
		}

		if ( belowLower ) {
			bst_search_Rec(node->right[t],  f, t);
		}

		if ( inBetween ) {
			bst_search_Rec(node->left[t],  f, t);
			res_insert(f, node->d);
			bst_search_Rec(node->right[t],  f, t);
		}
	}
}

// Inserts a data entry into a results structure
// (provided it is within the bounds)
static void res_insert(results_t* res, float* d) {

	if(res->check(d,res)) {

		// Extend array if necessary
		if (res->numEl >= res->arrLen) {
			res->arrLen += RESULTS_LEN;
			res->arr = (float**)realloc(res->arr, res->arrLen * sizeof(float*));
			assert(res->arr != NULL);
		}

		res->arr[res->numEl] = d;
		res->numEl++;
	}
}

// Results filter which will include points on the bounds of the filter
int res_filterBoundInclude(float* d, results_t* res) {
	// check that item is insertable
	int insert = 1, lessThanLo = 0, moreThanHi = 0;
	int i=0;
	for (i=0;i<res->dim;i++) {

		lessThanLo = d[i] < (res->filter[i]).lo;
		moreThanHi = d[i] > (res->filter[i]).hi;
		if ( lessThanLo || moreThanHi ) {
			insert = 0;
		}
	}
	return insert;
}

// Results filter which will include points inside bounds of the filter
int res_filterBoundExclude(float* d, results_t* res) {
	// check that item is insertable
	int insert = 1, lessThanLo = 0, moreThanHi = 0;
	int i=0;
	for (i=0;i<res->dim;i++) {

		lessThanLo = d[i] <= (res->filter[i]).lo;
		moreThanHi = d[i] >= (res->filter[i]).hi;
		if ( lessThanLo || moreThanHi ) {
			insert = 0;
		}
	}
	return insert;
}





/* * * * * * * * * * * * * * * * * * * * * * *  PRIVATE FUNCTIONS (BALANCING) */

// Correct imbalances in the tree
static void bst_balance( bst_t*bst, node_t* node_a, int dataIndex ) {

	assert(bst != NULL);
	assert(node_a != NULL);

	int a_depDiff = node_a->depth_R[dataIndex] - node_a->depth_L[dataIndex];
	int r_depDiff = 0;
	int l_depDiff = 0;

	if ( a_depDiff >= BST_BALANCE_THRESH ) {

		r_depDiff = node_a->right[dataIndex]->depth_R[dataIndex]
												- node_a->depth_L[dataIndex];
		if ( r_depDiff > 0) {
			bst_rightOuterRot(bst, node_a, dataIndex);
		} else {
			bst_rightInnerRot(bst, node_a, dataIndex);
		}

	} else if ( a_depDiff <= -BST_BALANCE_THRESH){

		l_depDiff = node_a->left[dataIndex]->depth_R[dataIndex]
												- node_a->depth_L[dataIndex];
		if ( l_depDiff < 0) {
			bst_leftOuterRot(bst, node_a, dataIndex);
		} else {
			bst_leftInnerRot(bst, node_a, dataIndex);
		}
	}
}

// Left outer rotation balancing
static node_t* bst_leftOuterRot(bst_t* bst, node_t* node_a, int dataIndex) {

	assert(bst != NULL);
	assert(node_a!=NULL);
	assert(node_a->left[dataIndex]!=NULL);
	node_t* node_b = node_a->left[dataIndex];
	node_t* parent = node_a->parent[dataIndex];

	// a.left points to b.right
	if (node_b->right[dataIndex] != NULL) {
		node_a->left[dataIndex] = node_b->right[dataIndex];
		node_a->left[dataIndex]->parent[dataIndex] = node_a;
		node_a->depth_L[dataIndex] = 1 + node_maxDepth(node_a->left[dataIndex], dataIndex);
	} else {
		node_a->left[dataIndex] = NULL;
		node_a->depth_L[dataIndex] = 0;
	}
	
	// b.right points to a
	node_b->right[dataIndex] = node_a;
	node_b->right[dataIndex]->parent[dataIndex] = node_b;
	node_b->depth_R[dataIndex] = 1 + node_maxDepth(node_b->right[dataIndex], dataIndex);
	
	// parent now points to b
	if (parent != NULL) {
		if (parent->left[dataIndex] == node_a) {
			parent->left[dataIndex] = node_b;
			node_b->parent[dataIndex] = parent;
		} else if (parent->right[dataIndex] == node_a) {
			parent->right[dataIndex] = node_b;
			node_b->parent[dataIndex] = parent;
		} else {
			exit(EXIT_FAILURE);
		}
	} else { // must account for when node_a is the bst root and parent==NULL
		bst->root[dataIndex] = node_b;
		node_b->parent[dataIndex] = NULL;
	}
	fixParentDepth(bst, node_b, dataIndex);
	return node_b;
}

// Right outer rotation balancing
static node_t* bst_rightOuterRot(bst_t* bst, node_t* node_a, int dataIndex) {
	
	assert(bst != NULL);
	assert(node_a!=NULL);
	assert(node_a->right[dataIndex]!=NULL);
	node_t* node_b = node_a->right[dataIndex];
	node_t* parent = node_a->parent[dataIndex];

	// a.right points to b.left
	if (node_b->left[dataIndex]!= NULL) {
		node_a->right[dataIndex] = node_b->left[dataIndex];
		(node_a->right[dataIndex])->parent[dataIndex] = node_a;
		node_a->depth_R[dataIndex] = 1 + node_maxDepth(node_a->right[dataIndex], dataIndex);
	} else {
		node_a->right[dataIndex] = NULL;
		node_a->depth_R[dataIndex] = 0;
	}
	
	// b.left points to a
	node_b->left[dataIndex] = node_a;
	(node_b->left[dataIndex])->parent[dataIndex] = node_b;
	node_b->depth_L[dataIndex] = 1 + node_maxDepth(node_b->left[dataIndex], dataIndex);
	
	// parent now points to b
	if (parent != NULL) {
		if (parent->right[dataIndex] == node_a) {
			parent->right[dataIndex] = node_b;
			node_b->parent[dataIndex] = parent;
		} else if (parent->left[dataIndex] == node_a) {
			parent->left[dataIndex] = node_b;
			node_b->parent[dataIndex] = parent;
		} else {
			exit(EXIT_FAILURE);
		}
	} else { // must account for when node_a is the bst root and parent==NULL
		bst->root[dataIndex] = node_b;
		node_b->parent[dataIndex] = NULL;
	}
	fixParentDepth(bst, node_b, dataIndex);
	return node_b;
}

// Left inner rotation balancing
static node_t* bst_leftInnerRot( bst_t* bst, node_t* a, int dataIndex){

	assert(a!=NULL);
	assert(bst != NULL);

	node_t* b = a->left[dataIndex];
	assert(b!=NULL);
	node_t* c = b->right[dataIndex];
	assert(c!=NULL);
	node_t* parent = a->parent[dataIndex];
	
	// a.left points to c.right
	if (c->right[dataIndex] != NULL) {
		a->left[dataIndex] = c->right[dataIndex];
		a->left[dataIndex]->parent[dataIndex] = a;
		a->depth_L[dataIndex] = 1 + node_maxDepth(a->left[dataIndex], dataIndex);
	} else {
		a->left[dataIndex] = NULL;
		a->depth_L[dataIndex] = 0;
	}
	
	// b.right points to c.left
	if (c->left[dataIndex] != NULL) {
		b->right[dataIndex] = c->left[dataIndex];
		b->right[dataIndex]->parent[dataIndex] = b;
		b->depth_R[dataIndex] = 1 + node_maxDepth(b->right[dataIndex], dataIndex);
	} else {
		b->right[dataIndex] = NULL;
		b->depth_R[dataIndex] = 0;
	}

	// c.left points to b
	c->left[dataIndex] = b;
	c->left[dataIndex]->parent[dataIndex] = b;
	c->depth_L[dataIndex] = 1 + node_maxDepth(c->left[dataIndex], dataIndex);
	
	// c.right points to a
	c->right[dataIndex] = a;
	c->right[dataIndex]->parent[dataIndex] = a;
	c->depth_R[dataIndex] = 1 + node_maxDepth(c->right[dataIndex], dataIndex);
	
	// parent now points to c
	if (parent != NULL) {
		if (parent->left[dataIndex] == a) {
			parent->left[dataIndex] = c;
			c->parent[dataIndex] = parent;
		} else if (parent->right[dataIndex] == a) {
			parent->right[dataIndex] = c;
			c->parent[dataIndex] = parent;
		} else {
			exit(EXIT_FAILURE);
		}
	} else { // must account for when node_a is the bst root and parent==NULL
		bst->root[dataIndex] = c;
		c->parent[dataIndex] = NULL;
	}
	fixParentDepth(bst, c, dataIndex);
	return c;
}

// Right inner rotation balancing
static node_t* bst_rightInnerRot( bst_t* bst, node_t* a, int dataIndex){

	assert(a!=NULL);
	assert(bst != NULL);

	node_t* b = a->right[dataIndex];
	assert(b!=NULL);
	node_t* c = b->left[dataIndex];
	assert(c!=NULL);
	node_t* parent = a->parent[dataIndex];
	
	// a.right points to c.left
	if (c->left[dataIndex] != NULL) {
		a->right[dataIndex] = c->left[dataIndex];
		a->right[dataIndex]->parent[dataIndex] = a;
		a->depth_R[dataIndex] = 1 + node_maxDepth(a->right[dataIndex], dataIndex);
	} else {
		a->right[dataIndex] = NULL;
		a->depth_R[dataIndex] = 0;
	}
	
	// b.left points to c.right
	if (c->right[dataIndex] != NULL) {
		b->left[dataIndex] = c->right[dataIndex];
		b->left[dataIndex]->parent[dataIndex] = b;
		b->depth_L[dataIndex] = 1 + node_maxDepth(b->left[dataIndex], dataIndex);
	} else {
		b->left[dataIndex] = NULL;
		b->depth_L[dataIndex] = 0;
	}

	// c.left points to a
	c->left[dataIndex] = a;
	c->left[dataIndex]->parent[dataIndex] = c;
	c->depth_L[dataIndex] = 1 + node_maxDepth(c->left[dataIndex], dataIndex);
	
	// c.right points to b
	c->right[dataIndex] = b;
	c->right[dataIndex]->parent[dataIndex] = c;
	c->depth_R[dataIndex] = 1 + node_maxDepth(c->right[dataIndex], dataIndex);
	
	
	// parent now points to c
	if (parent != NULL) {
		if (parent->left[dataIndex] == a) {
			parent->left[dataIndex] = c;
			c->parent[dataIndex] = parent;
		} else if (parent->right[dataIndex] == a) {
			parent->right[dataIndex] = c;
			c->parent[dataIndex] = parent;
		} else {
			exit(EXIT_FAILURE);
		}
		
	} else { // must account for when node_a is the bst root and parent==NULL
		bst->root[dataIndex] = c;
		c->parent[dataIndex] = NULL;
	}
	fixParentDepth(bst, c, dataIndex);
	return c;
}

// Returns the maximum depth of the left and right branches
static int node_maxDepth(node_t* node, int dataIndex) {
	return MAX(node->depth_L[dataIndex], node->depth_R[dataIndex]);
}

// Propogates a change in depth up the tree towards the root
static void fixParentDepth(bst_t* bst, node_t* node_a, int dataIndex) {
	
	node_t* parent = node_a->parent[dataIndex];
	node_t* next = node_a;

	while (parent!=NULL) {

		if (parent->left[dataIndex] == next) {
			parent->depth_L[dataIndex] = 1 + node_maxDepth(next, dataIndex);
		} else if (parent->right[dataIndex] == next) {
			parent->depth_R[dataIndex] = 1 + node_maxDepth(next, dataIndex);
		} else {
			printf("The tree is broken!\n");
			exit(EXIT_FAILURE);
		}
		next = parent;
		parent = parent->parent[dataIndex];
	}
}
============================================
src/tasks.c
16:45:21_Tuesday_29_August_2017
============================================
/***************************************************************************
 *
 *   File        : tasks.c
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <float.h>
#include <sys/time.h>
#include <string.h>
#include <assert.h>
#include "tasks.h"
#include "data_handler.h"

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * TASK FUNCTIONS */

void maxveldiff(bst_t* bst) {

	assert(bst!=NULL);

	FILE* fp = fopen(T1_CSV, FILE_REWRITE);
	assert(fp!=NULL);

	// search for max/min
	resultsFilter_t searchFilter[] = {
		{MVD_THRESH, FLT_MAX},
		{-FLT_MAX, FLT_MAX},
		{-FLT_MAX, FLT_MAX},
		{-FLT_MAX, FLT_MAX}
	};

	results_t* maxU = res_search(bst, searchFilter, mvdMaxU);
	results_t* minU = res_search(bst, searchFilter, mvdMinU);
	results_t* maxV = res_search(bst, searchFilter, mvdMaxV);
	results_t* minV = res_search(bst, searchFilter, mvdMinV);

	// print max/min
	bst_printKey(bst, fp);
	bst_printData(bst->dim, maxU->arr[0], fp);
	bst_printData(bst->dim, minU->arr[0], fp);
	bst_printData(bst->dim, maxV->arr[0], fp);
	bst_printData(bst->dim, minV->arr[0], fp);

	// free results structures
	res_free(minU);
	res_free(maxU);
	res_free(minV);
	res_free(maxV);

	fflush(fp);
	fclose(fp);
}

void coarsegrid(bst_t* bst, int resolution) {

	assert(bst!=NULL);

	cell_t* cells[resolution*resolution];
	cell_t* tmpCell = NULL;

	resultsFilter_t bound[] = {
		{-FLT_MAX, FLT_MAX},
		{-FLT_MAX, FLT_MAX},
		{-FLT_MAX, FLT_MAX},
		{-FLT_MAX, FLT_MAX}
	};

	float delta_x = (GRID_X_MAX - GRID_X_MIN) / resolution;
	float delta_y = (GRID_Y_MAX - GRID_Y_MIN) / resolution;

	int x_i=0, y_i=0, cell_i=0;
	for ( x_i=0 ; x_i<resolution ; x_i++ ) {
		for ( y_i=0 ; y_i<resolution ; y_i++ ) {

			// generate bounds for search
			bound[BST_X].lo = GRID_X_MIN + x_i*delta_x;
			bound[BST_X].hi = bound[BST_X].lo + delta_x;
			bound[BST_Y].lo = GRID_Y_MIN + y_i*delta_y;
			bound[BST_Y].hi = bound[BST_Y].lo+ delta_y;

			// search data and generate cells
			tmpCell = generateCell(bst, bound);
			if (tmpCell != NULL) {
				cells[cell_i] = tmpCell;
				cell_i++;
			}
		}
	}

	// sort, print, free memory
	qsort(cells, cell_i, sizeof(cell_t*), cellCmp);
	printTask2(cells, cell_i);
	destroyCells(cells, cell_i);
}

void velstat(bst_t* bst) {

	assert(bst!=NULL);

	FILE* fp = fopen(T3_CSV, FILE_REWRITE);
	assert(fp!=NULL);
	fprintf(fp, T3_HEADER);

	float thresh = T3_INIT_THRESH;
	float percent = 0;
	int totalPoints = bst->numNodes;
	int numPointsFound = 0;
	int i = 0;
	
	while(percent<T3_PERCENT_END) {

		thresh = T3_INIT_THRESH + i*T3_THRESH_INTERVAL;
		i++;

		resultsFilter_t searchFilter[] = {
			{-FLT_MAX, FLT_MAX},
			{-FLT_MAX, FLT_MAX},
			{-FLT_MAX, thresh},
			{-FLT_MAX, FLT_MAX}
		};

		results_t* res = res_search(bst, searchFilter, res_filterBoundExclude);
		numPointsFound = res->numEl;
		res_free(res);
		percent = PERCENT(numPointsFound, totalPoints);
		fprintf(fp,"%.6f,%d,%.6lf\n", thresh, numPointsFound, percent);
	}

	fflush(fp);
	fclose(fp);
}

void wakevis(bst_t* bst) {

	// get spacing
	float* yheight = getYs_t4(bst);

	// Print wake profile using given skeleton
	int i,j;
	FILE *ft42;
	ft42 = fopen("task4_2.txt","w");
	for (j = 11; j>=0; j--){
	for (i=0;i<yheight[j]-yheight[0]+4;i++){
 		fprintf(ft42, " ");
	}
		fprintf(ft42, "*\n");
	}
	for (i=0;i<5; i++){
		fprintf(ft42, "III\n");
	}
	for(j = 0; j<12; j++ ){
		for (i=0;i<yheight[j]-yheight[0]+4;i++){
			fprintf(ft42, " ");
		}
		fprintf(ft42, "*\n");
	}
	fclose(ft42);

	/* Cleanup */
	free(yheight);
}




/* * * * * * * * * * * * * * * * * * * * * * * * * *  TASK 1 HELPER FUNCTIONS */
// These functions are called by the bst search function to decide when to
// insert items into the search array. They are used in task 1 to replace 
// previous results so that the correct maximum/minimum is found

int mvdMaxU(float* d, results_t* res) {
	
	assert(res->numEl == 1 || res->numEl == 0);
	
	if (res_filterBoundExclude(d, res)) {
		if (res->numEl == 0) {
			return 1; // insert item if it's the first result
		} else if (res->numEl == 1) {
	
			if (d[BST_U] > res->arr[0][BST_U]) { // found a new maximum U
				res->arr[0] = d; // replace previous result
			} else if (
				(d[BST_U] == res->arr[0][BST_U]) && // same maximum U
				(d[BST_X] < res->arr[0][BST_X])		// earlier in the domain X
			) {
				res->arr[0] = d; // replace previous result
			} else if (
				(d[BST_U] == res->arr[0][BST_U]) && // same maximum U
				(d[BST_X] == res->arr[0][BST_X]) && // same domain X
				(d[BST_Y] < res->arr[0][BST_Y])		// lower Y
			) {
				res->arr[0] = d; // replace previous result
			}
			return 0;
	
		}
		exit(EXIT_FAILURE);
	}
	return 0;
}

int mvdMinU(float* d, results_t* res) {
	
	assert(res->numEl <= 1 && res->numEl >= 0);

	if (res_filterBoundExclude(d, res)) {
		if (res->numEl == 0) {
			return 1; // insert item if it's the first result
		} else if (res->numEl == 1) {
	
			if ( d[BST_U] < res->arr[0][BST_U] ) { // new min U found
				res->arr[0] = d; // replace item
			} else if ( 
				( d[BST_U] == res->arr[0][BST_U] ) && 	// same U
				( d[BST_X] < res->arr[0][BST_X] ) 		// earlier in domain X
			) {
				res->arr[0] = d; // replace item
			} else if (
				( d[BST_U] == res->arr[0][BST_U] ) && 	// same U
				( d[BST_X] == res->arr[0][BST_X] ) &&	// same domain X
				( d[BST_Y] < res->arr[0][BST_Y] )		// lower domain Y
			) {
				res->arr[0] = d; // replace item
			}
			return 0;
		}
		exit(EXIT_FAILURE);
	}
	return 0;
}

int mvdMaxV(float* d, results_t* res) {
	
	assert(res->numEl <= 1 && res->numEl >= 0);

	if (res_filterBoundExclude(d, res)) {

		if (res->numEl == 0) {
			return 1; // insert item if it's the first result
		} else if (res->numEl == 1) {
			
			if ( d[BST_V] > res->arr[0][BST_V] ) { // new max X found
				res->arr[0] = d; // replace item
			} else if ( 
				( d[BST_V] == res->arr[0][BST_V] ) && 	// same V
				( d[BST_X] < res->arr[0][BST_X] ) 		// earlier in domain X
			) {
				res->arr[0] = d; // replace item
			} else if (
				( d[BST_V] == res->arr[0][BST_V] ) && 	// same V
				( d[BST_X] == res->arr[0][BST_X] ) &&	// same domain X
				( d[BST_Y] < res->arr[0][BST_Y] )		// lower domain Y
			) {
				res->arr[0] = d; // replace item
			}
	
			return 0;
		}
		exit(EXIT_FAILURE);

	}
	return 0;
}

int mvdMinV(float* d, results_t* res) {
	
	assert(res->numEl <= 1 && res->numEl >= 0);

	if (res_filterBoundExclude(d, res)) {

		if (res->numEl == 0) {
			return 1; // insert item if it's the first result
		} else if (res->numEl == 1) {
			
			if ( d[BST_V] < res->arr[0][BST_V] ) { // new min V found
				res->arr[0] = d; // replace item
			} else if ( 
				( d[BST_V] == res->arr[0][BST_V] ) && 	// same V
				( d[BST_X] < res->arr[0][BST_X] ) 		// earlier in domain X
			) {
				res->arr[0] = d; // replace item
			} else if (
				( d[BST_V] == res->arr[0][BST_V] ) && 	// same V
				( d[BST_X] == res->arr[0][BST_X] ) &&	// same domain X
				( d[BST_Y] < res->arr[0][BST_Y] )		// lower Y
			) {
				res->arr[0] = d; // replace item
			}
	
			return 0;
		}
		exit(EXIT_FAILURE);

	}
	return 0;
}




/* * * * * * * * * * * * * * * * * * * * * * * * * *  TASK 2 HELPER FUNCTIONS */

// Generates a new cell struct for task 2
cell_t* generateCell(bst_t* bst, resultsFilter_t* bounds){

	assert(bst!=NULL);
	assert(bounds!=NULL);
	cell_t* cell = (cell_t*)malloc(sizeof(cell_t));
	assert(cell != NULL);

	// Get points by searching the tree
	cell->points = res_search(bst, bounds, res_filterBoundInclude);
		
	// Calculate average and score if there were results found, else return null
	float* sum = (float*)calloc(bst->dim, sizeof(float));
	assert(sum!=NULL);
	cell->av = sum;

	if ((cell->points)->numEl != 0) {

		// Calculate average
		int i=0, dataIndex = 0;
		for ( dataIndex=0; dataIndex<bst->dim; dataIndex++ ) {
			for ( i=0; i<(cell->points)->numEl; i++ ) {
				sum[dataIndex] += (cell->points)->arr[i][dataIndex];
			}
			cell->av[dataIndex] = sum[dataIndex]/(cell->points)->numEl;
		}

		// Calculate score
		cell->score = T2_SCORE( 
			cell->av[BST_X], cell->av[BST_Y], cell->av[BST_U], cell->av[BST_V] );

		return cell;
	} else {
		destroyCell(cell);
		return NULL;
	}
}

// frees a list of cells
void destroyCells(cell_t* cell[], int n) {

	assert(cell!=NULL);

	int i=0;
	for (i=0;i<n;i++) { 
		if (cell[i]!=NULL) {
			destroyCell(cell[i]);
		};
	}
}

// frees memory associated with a cell
void destroyCell(cell_t* cell) {

	assert(cell!=NULL);
	res_free(cell->points);
	free(cell->av);
	free(cell);
}

// Prints the output of task 2
void printTask2(cell_t* cells[], int n) {
	assert(cells != NULL);

	FILE* fp = fopen(T2_CSV,FILE_REWRITE);
	assert(fp!=NULL);
	fprintf(fp, T2_HEADER);

	int i=0;
	for (i=0;i<n;i++) {
		fprintf(fp, "%.6f,%.6f,%.6f,%.6f,%.6f\n",
			cells[i]->av[BST_X],
			cells[i]->av[BST_Y],
			cells[i]->av[BST_U],
			cells[i]->av[BST_V],
			cells[i]->score
			);
	}
	
	fflush(fp);
	fclose(fp);
}

// Check function used to determine if an item should be inserted, returns 1
// because we only care about whether the item is within the bounds, which is
// checked during search in data_handler.c - res_insert(..)
int noCheck(float* a, results_t* b) {
	return 1;
}

// Comparison function used to qsort cells by their score
int cellCmp(const void* a, const void* b) {

	float a_s = (*(cell_t**)a)->score;
	float b_s = (*(cell_t**)b)->score;

	return (a_s < b_s) - (a_s > b_s);
}




/* * * * * * * * * * * * * * * * * * * * * * * * * *  TASK 4 HELPER FUNCTIONS */

float* getYs_t4(bst_t* bst) {

	assert(bst!=NULL);

	FILE* fp = fopen(T4_1_CSV, FILE_REWRITE);
	assert(fp!=NULL);
	fprintf(fp, T4_HEADER);

	float* ys = (float*)calloc(T4_NUM_Y,sizeof(float));
	assert(ys!=NULL);

	resultsFilter_t bound[] = {
		{-FLT_MAX, FLT_MAX},
		{-FLT_MAX, FLT_MAX},
		{-FLT_MAX, FLT_MAX},
		{-FLT_MAX, FLT_MAX}
	};

	int i=0;
	for (i=0; i<T4_NUM_Y; i++) {

		bound[BST_X].lo = i*T4_X_INTERVAL + T4_INIT_X - TOLERANCE;
		bound[BST_X].hi = i*T4_X_INTERVAL + T4_INIT_X + TOLERANCE;
		
		results_t* res = res_search(bst, bound, mvdMaxU);
		if (res->numEl == 1) {
			ys[i] = SPACING( (res->arr[0])[BST_Y] );
			fprintf(fp, "%.6f,%.6f\n",
				(res->arr[0])[BST_X],
				(res->arr[0])[BST_Y]);
			res_free(res);
		}
	}

	fflush(fp);
	fclose(fp);
	return ys;
}