============================================
vis/output.txt
12:13:46_Sunday_27_August_2017
============================================

Compiling with gcc -Wall -std=c99 ... 
Compilation succeeded.
==2680== Memcheck, a memory error detector
==2680== Copyright (C) 2002-2012, and GNU GPL'd, by Julian Seward et al.
==2680== Using Valgrind-3.8.1 and LibVEX; rerun with -h for copyright info
==2680== Command: flow ../data/flow_data.csv 24
==2680== 
TASK1: 1356.00 milliseconds
TASK2: 8251.55 milliseconds
TASK3: 6949.37 milliseconds
TASK4: 16.43 milliseconds
==2680== 
==2680== HEAP SUMMARY:
==2680==     in use at exit: 0 bytes in 0 blocks
==2680==   total heap usage: 1,805,664 allocs, 1,805,664 frees, 2,657,145,159 bytes allocated
==2680== 
==2680== All heap blocks were freed -- no leaks are possible
==2680== 
==2680== For counts of detected and suppressed errors, rerun with: -v
==2680== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 6 from 6)
============================================
Test for input file: flow_data.csv
Files ../data/TRUE_SOLN.txt and vis/sebastianb1-output.txt differ
 
Oops, your results seem to be INCORRECT.  :(
 
 
Your wake profile seems to be CORRECT.  :)
 
============================================
vis/sebastianb1-output.txt
12:13:46_Sunday_27_August_2017
============================================
======================================================
                      TASK 1                          
======================================================
x,y,u,v
20.011999,-5.430400,1.024000,-0.001540
20.011999,-0.080000,0.707800,0.000097
20.011999,-1.403700,0.827750,0.006426
20.011999,1.200500,0.808700,-0.006204
======================================================
                      TASK 2                          
======================================================
x,y,u,v,S
11.232257,4.107626,1.025795,0.004647,8.577130
11.232256,-4.134958,1.025879,-0.004655,8.571089
11.232248,-2.447983,0.970317,0.000206,8.440540
11.232248,2.451041,0.969236,-0.000799,8.430665
11.232260,5.792325,1.025813,0.005223,8.117107
11.232262,-5.818795,1.025837,-0.005208,8.109502
11.232265,7.471778,1.023463,0.005578,7.586709
11.232264,-7.505627,1.023469,-0.005564,7.576205
13.723968,4.107610,1.022793,0.003240,7.139708
13.723969,-4.134946,1.023244,-0.003258,7.138934
11.232266,9.138704,1.020956,0.005865,7.050760
11.232267,-9.175634,1.020956,-0.005854,7.039413
13.723960,5.792312,1.025262,0.004073,6.882746
13.723957,-5.818803,1.025290,-0.004051,6.878167
13.723977,-2.447983,0.958214,0.001664,6.873561
13.723977,2.451042,0.957208,-0.001942,6.866085
11.232233,0.821661,0.741325,-0.006114,6.582611
13.723948,7.471778,1.022961,0.004394,6.546563
11.232234,-0.841661,0.736854,0.006019,6.542054
11.232268,-10.783289,1.018522,-0.006013,6.541437
13.723951,-7.505623,1.022969,-0.004373,6.539823
11.232268,10.811244,1.018435,0.006029,6.532751
13.723944,9.138705,1.020590,0.004653,6.189863
13.723945,-9.175621,1.020589,-0.004632,6.182175
16.231810,-4.134945,1.019956,-0.001988,6.089224
16.231808,4.107606,1.018746,0.001835,6.084447
11.232268,-12.477984,1.016097,-0.006044,6.052335
11.232268,12.503580,1.016016,0.006056,6.045005
16.231800,5.792313,1.024636,0.002987,5.945345
16.231798,-5.818796,1.024684,-0.002970,5.942545
13.723946,-10.783305,1.018323,-0.004807,5.834542
13.723946,10.811248,1.018242,0.004834,5.828309
16.231791,2.451040,0.947468,-0.002961,5.771712
16.231791,-2.447987,0.947158,0.002703,5.769977
16.231789,7.471777,1.022455,0.003354,5.722003
16.231792,-7.505620,1.022465,-0.003325,5.717525
11.232272,-14.143746,1.013907,-0.005962,5.613807
11.232272,14.165752,1.013843,0.005972,5.608098
13.723946,-12.477991,1.016060,-0.004906,5.477919
16.231785,9.138719,1.020201,0.003639,5.476864
13.723946,12.503587,1.016003,0.004928,5.472530
16.231779,-9.175626,1.020199,-0.003609,5.471527
13.723983,0.821662,0.748993,-0.005409,5.447937
13.723983,-0.841661,0.743418,0.006221,5.406957
18.729746,-4.134948,1.016128,-0.000833,5.297647
18.729744,4.107605,1.014275,0.000769,5.289608
11.232272,-15.743660,1.012038,-0.005802,5.233021
11.232272,15.760257,1.011989,0.005811,5.229116
16.231781,-10.783319,1.018057,-0.003816,5.224272
18.729738,5.792321,1.023899,0.002109,5.222665
18.729736,-5.818792,1.023959,-0.002046,5.220884
16.231781,10.811255,1.017979,0.003852,5.219730
13.723948,-14.143762,1.013999,-0.004924,5.145259
13.723948,14.165766,1.013985,0.004943,5.141068
18.729727,7.471783,1.021900,0.002503,5.067686
18.729731,-7.505599,1.021912,-0.002448,5.064592
18.729761,2.451037,0.939103,-0.003668,4.971609
18.729761,-2.447989,0.938097,0.003630,4.966388
16.231781,-12.478005,1.015924,-0.003966,4.962135
16.231781,12.503599,1.015851,0.003997,4.958000
18.729723,9.138704,1.019769,0.002808,4.893271
18.729719,-9.175631,1.019762,-0.002763,4.889432
11.232272,-17.429951,1.010311,-0.005577,4.872413
11.232272,17.440319,1.010278,0.005585,4.870209
13.723948,-15.743663,1.012254,-0.004877,4.846707
13.723948,15.760258,1.012211,0.004893,4.843602
16.231783,-14.143774,1.013982,-0.004050,4.709785
18.729719,-10.783300,1.017723,-0.003001,4.709069
16.231783,14.165778,1.013936,0.004076,4.706409
18.729719,10.811278,1.017660,0.003048,4.705733
21.220390,-4.134952,1.011950,0.000005,4.680727
21.220388,4.107605,1.009822,0.000063,4.672012
16.231773,0.821661,0.757141,-0.005253,4.658709
21.220390,5.792321,1.023123,0.001464,4.651255
21.220390,-5.818790,1.023144,-0.001347,4.649875
16.231775,-0.841661,0.751508,0.005427,4.623764
13.723948,-17.429962,1.010605,-0.004775,4.555514
13.723948,17.440323,1.010573,0.004789,4.553697
11.232275,19.098505,1.008818,0.005331,4.553181
21.220392,7.471786,1.021339,0.001840,4.539820
21.220392,-7.505597,1.021324,-0.001759,4.537483
11.232272,-19.195370,1.008760,-0.005305,4.535815
18.729719,-12.478016,1.015692,-0.003190,4.513082
18.729719,12.503621,1.015638,0.003229,4.509993
16.231783,-15.743667,1.012309,-0.004078,4.476768
16.231783,15.760259,1.012263,0.004100,4.474276
21.220394,9.138703,1.019315,0.002144,4.411755
21.220396,-9.175627,1.019288,-0.002085,4.408845
21.220402,2.451038,0.932009,-0.003861,4.363073
21.220402,-2.447990,0.930697,0.004142,4.357009
18.729721,-14.143782,1.013850,-0.003321,4.319759
18.729721,14.165778,1.013805,0.003353,4.317130
13.723948,19.098515,1.009157,0.004649,4.291029
13.723948,-19.195353,1.009101,-0.004627,4.276479
21.220398,-10.783287,1.017348,-0.002340,4.274038
21.220398,10.811271,1.017300,0.002394,4.271560
16.231783,-17.429972,1.010727,-0.004061,4.243661
16.231783,17.440323,1.010704,0.004080,4.242216
23.747606,5.792321,1.022307,0.000949,4.182277
23.747608,-5.818793,1.022326,-0.000839,4.181275
23.747610,-4.134954,1.007727,0.000562,4.180590
23.747608,4.107605,1.005553,-0.000461,4.172380
18.729721,-15.743662,1.012250,-0.003400,4.137119
18.729721,15.760260,1.012214,0.003427,4.135170
21.220398,-12.478016,1.015409,-0.002553,4.124808
21.220398,12.503630,1.015367,0.002596,4.122462
23.747612,7.471786,1.020798,0.001313,4.100366
23.747610,-7.505597,1.020736,-0.001234,4.098440
18.729771,0.821663,0.765873,-0.004764,4.085218
18.729769,-0.841661,0.760082,0.004827,4.054141
16.231785,19.098516,1.009338,0.004025,4.027012
16.231783,-19.195354,1.009282,-0.004003,4.014956
23.747614,9.138702,1.018854,0.001606,4.004097
23.747616,-9.175630,1.018800,-0.001551,4.001794
21.220396,-14.143783,1.013646,-0.002714,3.974786
21.220396,14.165779,1.013613,0.002750,3.972753
18.729721,-17.429987,1.010738,-0.003442,3.950490
18.729721,17.440329,1.010715,0.003465,3.949313
23.747618,-10.783273,1.016947,-0.001807,3.899165
23.747618,10.811264,1.016919,0.001858,3.897329
23.747620,2.451042,0.926349,-0.003749,3.880228
23.747620,-2.447993,0.924848,0.004125,3.873999
21.220396,-15.743663,1.012113,-0.002828,3.830456
21.220396,15.760260,1.012087,0.002858,3.828926
26.251637,5.792320,1.021452,0.000536,3.799613
26.251637,-5.818793,1.021495,-0.000480,3.798965
23.747618,-12.478017,1.015088,-0.002030,3.783936
23.747618,12.503633,1.015060,0.002070,3.782150
26.251627,-4.134953,1.003722,0.000923,3.776903
18.729721,19.098515,1.009401,0.003470,3.773502
26.251629,4.107605,1.001621,-0.000879,3.769598
18.729721,-19.195339,1.009336,-0.003448,3.763522
26.251637,7.471784,1.020287,0.000899,3.738105
26.251637,-7.505597,1.020187,-0.000854,3.736469
21.220396,-17.429989,1.010663,-0.002912,3.680364
21.220396,17.440334,1.010646,0.002936,3.679425
23.747622,-14.143783,1.013395,-0.002208,3.666351
23.747622,14.165789,1.013372,0.002241,3.664775
26.251637,9.138698,1.018409,0.001181,3.663760
26.251635,-9.175634,1.018331,-0.001150,3.661878
21.220409,0.821665,0.774066,-0.004347,3.645067
21.220407,-0.841661,0.769440,0.003977,3.623141
26.251635,-10.783267,1.016547,-0.001396,3.581911
26.251635,10.811271,1.016536,0.001430,3.580527
23.747622,-15.743673,1.011922,-0.002344,3.551571
23.747622,15.760262,1.011904,0.002372,3.550362
21.220394,19.098511,1.009383,0.002984,3.535603
21.220396,-19.195330,1.009321,-0.002964,3.527374
26.251612,2.451038,0.921935,-0.003732,3.496739
26.251612,-2.447992,0.920714,0.003888,3.492148
26.251635,-12.478019,1.014755,-0.001616,3.491178
26.251635,12.503633,1.014738,0.001646,3.489801
28.747822,5.792318,1.020547,0.000188,3.480061
28.747822,-5.818793,1.020642,-0.000247,3.479761
28.747761,-4.134956,1.000036,0.001137,3.443223
28.747774,4.107604,0.997964,-0.001258,3.436546
28.747814,7.471784,1.019799,0.000570,3.433327
28.747816,-7.505596,1.019693,-0.000590,3.431984
23.747622,-17.429993,1.010527,-0.002454,3.430449
23.747622,17.440342,1.010515,0.002478,3.429696
26.251638,-14.143787,1.013125,-0.001799,3.397543
26.251638,14.165797,1.013108,0.001826,3.396299
28.747812,9.138696,1.017975,0.000847,3.374644
28.747808,-9.175632,1.017899,-0.000853,3.373137
23.747623,19.098497,1.009294,0.002556,3.311927
28.747805,-10.783267,1.016171,-0.001078,3.309611
28.747805,10.811275,1.016159,0.001091,3.308508
23.747622,-19.195326,1.009235,-0.002538,3.305144
26.251638,-15.743679,1.011700,-0.001945,3.305065
26.251638,15.760245,1.011689,0.001970,3.304109
23.747623,0.821664,0.781577,-0.003539,3.289246
23.747623,-0.841660,0.778463,0.003570,3.276042
28.747805,-12.478022,1.014430,-0.001289,3.236952
28.747805,12.503633,1.014415,0.001307,3.235851
31.256681,-5.818791,1.019843,-0.000117,3.207691
31.256683,5.792314,1.019528,-0.000068,3.207187
26.251638,-17.429998,1.010355,-0.002071,3.206347
26.251638,17.440319,1.010346,0.002094,3.205738
28.747677,2.451037,0.918328,-0.003801,3.182922
28.747677,-2.447988,0.917206,0.003844,3.179064
31.256680,7.471783,1.019317,0.000327,3.171755
31.256680,-7.505598,1.019272,-0.000400,3.170837
28.747799,-14.143789,1.012847,-0.001469,3.161321
31.256687,-4.134959,0.996602,0.001157,3.160908
28.747799,14.165795,1.012832,0.001489,3.160313
31.256687,4.107602,0.994559,-0.001492,3.154787
31.256678,9.138696,1.017555,0.000594,3.124664
31.256676,-9.175625,1.017511,-0.000625,3.123535
26.251640,19.098476,1.009170,0.002192,3.108604
26.251638,-19.195322,1.009107,-0.002176,3.102958
28.747799,-15.743679,1.011468,-0.001619,3.085957
28.747799,15.760236,1.011455,0.001639,3.085171
31.256674,-10.783274,1.015817,-0.000829,3.072233
31.256674,10.811280,1.015787,0.000828,3.071294
31.256674,-12.478026,1.014117,-0.001026,3.013246
31.256674,12.503633,1.014092,0.001037,3.012321
28.747799,-17.430000,1.010162,-0.001753,3.004736
28.747799,17.440310,1.010154,0.001774,3.004233
26.251602,0.821663,0.788862,-0.003197,3.003559
26.251604,-0.841660,0.785884,0.003284,2.992149
33.763103,-5.818790,1.019070,0.000058,2.974444
33.763100,5.792313,1.018505,-0.000195,2.973184
31.256672,-14.143791,1.012571,-0.001201,2.951431
31.256672,14.165795,1.012552,0.001217,2.950597
33.763107,7.471780,1.018869,0.000178,2.946413
33.763103,-7.505601,1.018911,-0.000225,2.945910
28.747793,19.098478,1.009012,0.001884,2.923527
33.763084,-4.134956,0.993553,0.001277,2.920899
31.256689,2.451035,0.915265,-0.003758,2.919285
28.747799,-19.195318,1.008949,-0.001871,2.918804
31.256689,-2.447983,0.914127,0.003535,2.915675
33.763088,4.107597,0.991442,-0.001516,2.914976
33.763107,9.138699,1.017159,0.000419,2.907995
33.763107,-9.175621,1.017160,-0.000434,2.907194
31.256672,-15.743678,1.011226,-0.001349,2.889405
31.256672,15.760222,1.011211,0.001368,2.888749
33.763111,-10.783277,1.015487,-0.000627,2.865104
33.763111,10.811281,1.015438,0.000634,2.864278
31.256672,-17.430004,1.009954,-0.001487,2.822045
31.256672,17.440308,1.009948,0.001506,2.821633
33.763111,-12.478030,1.013817,-0.000815,2.816541
33.763111,12.503636,1.013780,0.000830,2.815744
36.249504,-5.818790,1.018173,0.000303,2.773289
36.249504,5.792317,1.017563,-0.000227,2.771944
28.747681,0.821663,0.795910,-0.002985,2.767497
33.763115,-14.143791,1.012301,-0.000983,2.765403
33.763115,14.165796,1.012276,0.001002,2.764692
28.747673,-0.841663,0.792778,0.003131,2.756553
31.256672,19.098492,1.008837,0.001623,2.754158
36.249496,7.471777,1.018482,0.000101,2.751796
36.249500,-7.505602,1.018545,-0.000056,2.751458
31.256672,-19.195301,1.008775,-0.001611,2.750190
36.249496,9.138705,1.016809,0.000305,2.719924
36.249493,-9.175613,1.016822,-0.000276,2.719302
36.249493,-4.134953,0.990793,0.001504,2.715653
33.763115,-15.743678,1.010987,-0.001129,2.713817
33.763115,15.760221,1.010969,0.001149,2.713260
36.249496,4.107601,0.988613,-0.001487,2.709907
33.763065,2.451032,0.912558,-0.003553,2.695757
33.763065,-2.447982,0.911641,0.003332,2.693062
36.249489,-10.783274,1.015176,-0.000466,2.684275
36.249489,10.811283,1.015121,0.000496,2.683562
33.763115,-17.430002,1.009742,-0.001266,2.657445
33.763115,17.440310,1.009735,0.001286,2.657097
36.249489,-12.478032,1.013532,-0.000647,2.643742
36.249489,12.503643,1.013494,0.000674,2.643069
36.249477,-14.143789,1.012044,-0.000810,2.600915
36.249477,14.165797,1.012017,0.000835,2.600312
33.763115,19.098497,1.008650,0.001406,2.600256
33.763115,-19.195290,1.008593,-0.001393,2.596911
38.750923,-5.818790,1.017174,0.000389,2.595801
38.750927,5.792317,1.016610,-0.000263,2.594622
38.750919,7.471777,1.018161,0.000052,2.579929
38.750923,-7.505602,1.018162,0.000039,2.579511
31.256676,0.821663,0.802564,-0.002904,2.566788
36.249477,-15.743676,1.010750,-0.000951,2.557519
36.249477,15.760221,1.010735,0.000975,2.557055
31.256680,-0.841661,0.799492,0.002588,2.556913
38.750919,9.138705,1.016504,0.000226,2.553136
38.750919,-9.175613,1.016489,-0.000167,2.552553
38.750946,-4.134953,0.988155,0.001557,2.535623
38.750946,4.107601,0.985949,-0.001506,2.530150
38.750916,-10.783274,1.014873,-0.000346,2.523099
38.750916,10.811283,1.014832,0.000394,2.522525
36.249477,-17.430002,1.009534,-0.001087,2.509890
36.249477,17.440308,1.009525,0.001109,2.509589
36.249481,2.451031,0.910410,-0.003248,2.505805
36.249481,-2.447977,0.909656,0.003388,2.503747
38.750916,-12.478032,1.013257,-0.000518,2.488940
38.750916,12.503643,1.013226,0.000555,2.488385
36.249477,19.098501,1.008465,0.001227,2.461300
36.249477,-19.195288,1.008410,-0.001213,2.458453
38.750912,-14.143789,1.011791,-0.000673,2.452743
38.750912,14.165797,1.011771,0.000704,2.452246
41.255581,-5.818790,1.016236,0.000386,2.439129
41.255581,5.792326,1.015565,-0.000295,2.437734
41.255585,7.471784,1.017885,0.000012,2.427771
41.255581,-7.505602,1.017835,0.000070,2.427303
38.750912,-15.743676,1.010521,-0.000809,2.415955
38.750912,15.760221,1.010509,0.000836,2.415566
41.255585,9.138711,1.016237,0.000163,2.404974
41.255589,-9.175611,1.016189,-0.000105,2.404403
33.763035,0.821663,0.808532,-0.002777,2.394030
33.763039,-0.841661,0.805875,0.002167,2.386122
41.255589,-10.783267,1.014596,-0.000265,2.379359
41.255589,10.811281,1.014576,0.000314,2.378916
41.255585,-4.134954,0.985700,0.001507,2.377343
38.750912,-17.430002,1.009328,-0.000940,2.375423
38.750912,17.440308,1.009320,0.000964,2.375169
41.255585,4.107605,0.983487,-0.001532,2.372162
41.255589,-12.478031,1.012999,-0.000424,2.350273
41.255589,12.503648,1.012980,0.000462,2.349823
38.750965,2.451031,0.908831,-0.003007,2.340648
38.750965,-2.447977,0.908146,0.003156,2.338896
38.750912,19.098501,1.008281,0.001080,2.333894
38.750912,-19.195288,1.008223,-0.001065,2.331446
41.255596,-14.143785,1.011553,-0.000569,2.319399
41.255596,14.165796,1.011540,0.000601,2.318989
43.753895,-5.818790,1.015329,0.000415,2.300292
43.753902,5.792326,1.014519,-0.000355,2.298638
43.753899,7.471784,1.017629,-0.000043,2.292614
43.753895,-7.505602,1.017552,0.000096,2.292145
41.255596,-15.743669,1.010303,-0.000698,2.287953
41.255596,15.760220,1.010294,0.000725,2.287626
43.753899,9.138711,1.015991,0.000103,2.273008
43.753902,-9.175611,1.015920,-0.000064,2.272463
41.255596,-17.430002,1.009126,-0.000823,2.253195
41.255596,17.440311,1.009124,0.000848,2.252988
43.753906,-10.783267,1.014338,-0.000211,2.250929
43.753906,10.811281,1.014335,0.000247,2.250585
36.249508,0.821663,0.813833,-0.002333,2.244519
36.249504,-0.841660,0.811831,0.002144,2.238969
43.753922,-4.134954,0.983243,0.001538,2.237245
43.753918,4.107605,0.981181,-0.001501,2.232685
43.753906,-12.478031,1.012760,-0.000357,2.225925
43.753906,12.503648,1.012750,0.000388,2.225558
41.255604,19.098503,1.008103,0.000959,2.217472
41.255596,-19.195292,1.008041,-0.000944,2.215351
43.753914,-14.143785,1.011331,-0.000492,2.199352
43.753914,14.165796,1.011322,0.000519,2.199006
41.255592,2.451032,0.907735,-0.002801,2.196408
41.255592,-2.447978,0.907114,0.002962,2.194917
46.233654,-5.818785,1.014417,0.000438,2.176937
46.233658,5.792331,1.013474,-0.000454,2.175066
46.233650,7.471775,1.017377,-0.000106,2.172326
43.753914,-15.743669,1.010097,-0.000613,2.172243
43.753914,15.760220,1.010091,0.000638,2.171968
46.233654,-7.505609,1.017270,0.000111,2.171848
46.233650,9.138709,1.015750,0.000049,2.155292
46.233646,-9.175611,1.015675,-0.000041,2.154805
43.753914,-17.430002,1.008934,-0.000732,2.142207
43.753914,17.440311,1.008935,0.000755,2.142035
46.233643,-10.783256,1.014105,-0.000176,2.136105
46.233643,10.811277,1.014104,0.000195,2.135815
46.233643,-12.478024,1.012540,-0.000312,2.114396
46.233643,12.503650,1.012533,0.000332,2.114087
46.233673,-4.134953,0.980946,0.001516,2.113280
38.750992,0.821663,0.818682,-0.002040,2.112206
43.753925,19.098503,1.007926,0.000862,2.111259
46.233669,4.107606,0.979141,-0.001526,2.109502
43.753914,-19.195292,1.007866,-0.000848,2.109418
38.750992,-0.841660,0.817348,0.001889,2.108739
46.233635,-14.143776,1.011125,-0.000438,2.091318
46.233635,14.165796,1.011118,0.000458,2.091025
43.753941,2.451032,0.906952,-0.002657,2.069611
43.753941,-2.447978,0.906464,0.002822,2.068506
46.233635,-15.743661,1.009902,-0.000552,2.067748
46.233635,15.760221,1.009899,0.000572,2.067515
48.744907,-5.818790,1.013518,0.000418,2.064571
48.744919,7.471779,1.017086,-0.000147,2.062459
48.744904,5.792329,1.012393,-0.000540,2.062412
48.744919,-7.505603,1.017001,0.000103,2.062072
48.744915,9.138710,1.015502,0.000018,2.047624
48.744915,-9.175611,1.015446,-0.000035,2.047229
46.233635,-17.429995,1.008752,-0.000664,2.041592
46.233635,17.440319,1.008753,0.000683,2.041444
48.744911,-10.783261,1.013889,-0.000160,2.030890
48.744911,10.811280,1.013874,0.000163,2.030613
46.233635,19.098505,1.007759,0.000786,2.014591
46.233635,-19.195299,1.007699,-0.000773,2.012980
48.744911,-12.478028,1.012333,-0.000285,2.011924
48.744911,12.503648,1.012320,0.000297,2.011643
48.744892,-4.134955,0.978785,0.001426,2.000791
48.744896,4.107606,0.977284,-0.001565,1.997816
41.255650,0.821662,0.822965,-0.001809,1.994402
41.255642,-0.841661,0.822287,0.001694,1.992740
48.744904,-14.143781,1.010930,-0.000402,1.991767
48.744904,14.165796,1.010920,0.000417,1.991508
48.744904,-15.743665,1.009716,-0.000508,1.971166
48.744904,15.760220,1.009714,0.000525,1.970966
51.280861,-5.818784,1.012651,0.000395,1.962125
51.280865,7.471776,1.016792,-0.000120,1.962072
51.280861,-7.505614,1.016745,0.000085,1.961798
51.280861,5.792331,1.011316,-0.000493,1.959651
46.233685,2.451034,0.906329,-0.002486,1.957579
46.233685,-2.447977,0.906092,0.002654,1.957075
51.280865,9.138711,1.015257,0.000029,1.949088
51.280865,-9.175611,1.015236,-0.000043,1.948806
48.744904,-17.429998,1.008582,-0.000613,1.948294
48.744904,17.440315,1.008582,0.000631,1.948163
51.280865,-10.783255,1.013685,-0.000158,1.934427
51.280865,10.811271,1.013656,0.000162,1.934158
48.744900,19.098503,1.007598,0.000728,1.924630
48.744904,-19.195295,1.007540,-0.000716,1.923220
51.280865,-12.478020,1.012139,-0.000274,1.917761
51.280865,12.503646,1.012116,0.000285,1.917497
51.280865,-14.143773,1.010746,-0.000382,1.900054
51.280865,14.165792,1.010733,0.000397,1.899821
51.280861,-4.134952,0.976793,0.001344,1.898630
51.280861,4.107606,0.975459,-0.001488,1.896118
43.753971,0.821662,0.826939,-0.001720,1.889645
43.753967,-0.841661,0.826774,0.001520,1.889252
51.280865,-15.743662,1.009543,-0.000481,1.881960
51.280865,15.760221,1.009537,0.000497,1.881778
53.775055,7.471776,1.016535,-0.000049,1.872360
53.775055,-7.505614,1.016496,0.000069,1.872127
53.775063,-5.818784,1.011793,0.000390,1.870609
53.775066,5.792331,1.010312,-0.000402,1.867969
51.280865,-17.429991,1.008418,-0.000579,1.861852
51.280865,17.440323,1.008419,0.000596,1.861741
53.775055,9.138711,1.015047,0.000073,1.860898
53.775059,-9.175611,1.015041,-0.000060,1.860676
48.744884,2.451033,0.905853,-0.002426,1.856017
48.744884,-2.447977,0.905745,0.002458,1.855801
53.775059,-10.783255,1.013499,-0.000169,1.847914
53.775059,10.811271,1.013459,0.000187,1.847656
51.280865,19.098507,1.007445,0.000687,1.841029
51.280865,-19.195301,1.007386,-0.000675,1.839783
53.775059,-12.478020,1.011963,-0.000277,1.833140
53.775059,12.503646,1.011937,0.000295,1.832901
53.775059,-14.143773,1.010577,-0.000377,1.817454
53.775059,14.165792,1.010561,0.000395,1.817243
53.775074,-4.134952,0.974971,0.001364,1.807719
53.775070,4.107606,0.973724,-0.001356,1.805477
53.775059,-15.743662,1.009384,-0.000469,1.801432
53.775059,15.760221,1.009377,0.000486,1.801270
46.233646,-0.841661,0.830912,0.001442,1.796906
46.233639,0.821662,0.830558,-0.001595,1.796156
56.280659,7.471776,1.016313,0.000035,1.790089
56.280663,-7.505616,1.016236,0.000022,1.789812
56.280643,-5.818786,1.010923,0.000326,1.786695
56.280632,5.792331,1.009361,-0.000292,1.784019
53.775059,-17.429991,1.008272,-0.000560,1.783627
53.775059,17.440323,1.008271,0.000577,1.783525
56.280659,9.138717,1.014874,0.000133,1.779925
56.280655,-9.175612,1.014857,-0.000096,1.779711
56.280651,-10.783252,1.013325,-0.000195,1.768321
56.280651,10.811264,1.013292,0.000226,1.768100
53.775063,19.098507,1.007306,0.000661,1.765165
53.775059,-19.195301,1.007250,-0.000649,1.764063
51.280861,2.451036,0.905481,-0.002306,1.763720
51.280861,-2.447976,0.905450,0.002261,1.763666
56.280651,-12.478015,1.011799,-0.000293,1.755153
56.280651,12.503641,1.011777,0.000319,1.754947
56.280643,-14.143773,1.010422,-0.000386,1.741186
56.280643,14.165787,1.010408,0.000408,1.741001
56.280643,-15.743662,1.009238,-0.000469,1.726929
56.280643,15.760222,1.009232,0.000490,1.726788
56.280590,-4.134952,0.973323,0.001197,1.724763
56.280598,4.107606,0.972003,-0.001217,1.722486
58.725666,7.471776,1.016127,0.000117,1.716457
58.725670,-7.505610,1.016007,-0.000041,1.716131
48.744877,-0.841660,0.834807,0.001303,1.712351
58.725662,-5.818787,1.010140,0.000259,1.711718
56.280643,-17.429989,1.008132,-0.000553,1.711081
56.280643,17.440325,1.008131,0.000572,1.710990
48.744877,0.821662,0.834079,-0.001552,1.710871
58.725658,5.792330,1.008512,-0.000175,1.709035
58.725666,9.138723,1.014737,0.000193,1.707377
58.725662,-9.175611,1.014695,-0.000145,1.707144
58.725658,-10.783257,1.013171,-0.000233,1.696892
58.725658,10.811268,1.013152,0.000270,1.696717
56.280640,19.098507,1.007181,0.000649,1.694654
56.280643,-19.195305,1.007121,-0.000635,1.693665
58.725658,-12.478007,1.011650,-0.000322,1.685054
58.725658,12.503640,1.011637,0.000351,1.684882
53.775078,-2.447976,0.905302,0.002139,1.681760
53.775078,2.451036,0.905250,-0.002084,1.681660
58.725651,-14.143773,1.010283,-0.000406,1.672519
58.725651,14.165780,1.010276,0.000430,1.672365
58.725651,-15.743661,1.009106,-0.000482,1.659732
58.725651,15.760220,1.009106,0.000503,1.659614
58.725643,-4.134951,0.971897,0.001084,1.650893
58.725647,4.107605,0.970437,-0.001048,1.648465
61.238789,7.471776,1.015956,0.000163,1.646795
61.238789,-7.505616,1.015774,-0.000101,1.646391
58.725651,-17.429993,1.008004,-0.000559,1.645514
58.725651,17.440325,1.008011,0.000577,1.645446
61.238789,-5.818786,1.009314,0.000194,1.640771
61.238789,9.138717,1.014615,0.000238,1.638672
61.238785,-9.175612,1.014549,-0.000201,1.638420
61.238789,5.792331,1.007654,-0.000142,1.638139
51.280903,-0.841661,0.838465,0.001190,1.634825
51.280907,0.821662,0.837444,-0.001420,1.632844
58.725647,19.098507,1.007062,0.000647,1.630785
58.725651,-19.195309,1.007001,-0.000634,1.629895
61.238785,-10.783252,1.013029,-0.000280,1.629164
61.238785,10.811264,1.013024,0.000311,1.629028
61.238785,-12.478015,1.011515,-0.000361,1.618499
61.238785,12.503641,1.011509,0.000386,1.618356
61.238785,-14.143773,1.010154,-0.000437,1.607223
61.238785,14.165787,1.010150,0.000458,1.607091
56.280567,2.451035,0.905225,-0.001851,1.606895
56.280567,-2.447977,0.905149,0.001918,1.606764
61.238785,-15.743662,1.008983,-0.000506,1.595730
61.238785,15.760222,1.008984,0.000525,1.595628
61.238785,-17.429989,1.007889,-0.000575,1.582964
61.238785,17.440325,1.007895,0.000592,1.582904
63.747627,7.471777,1.015751,0.000174,1.582560
63.747627,-7.505609,1.015551,-0.000169,1.582152
61.238792,-4.134952,0.970451,0.001009,1.581100
61.238792,4.107606,0.968861,-0.001009,1.578557
63.747608,-5.818785,1.008512,0.000119,1.575490
63.747631,9.138728,1.014489,0.000272,1.575309
63.747635,-9.175611,1.014411,-0.000261,1.575060
63.747601,5.792329,1.006776,-0.000168,1.572836
61.238781,19.098507,1.006953,0.000655,1.569739
61.238785,-19.195305,1.006889,-0.000643,1.568933
63.747639,-10.783262,1.012898,-0.000335,1.566663
63.747639,10.811271,1.012899,0.000352,1.566551
53.775105,-0.841661,0.841630,0.001140,1.564901
53.775108,0.821662,0.840566,-0.001221,1.562933
63.747639,-12.478012,1.011391,-0.000410,1.557006
63.747639,12.503647,1.011387,0.000427,1.556884
63.747650,-14.143772,1.010039,-0.000479,1.546818
63.747650,14.165774,1.010038,0.000495,1.546704
58.725620,2.451034,0.905239,-0.001658,1.540133
58.725620,-2.447974,0.904877,0.001749,1.539521
63.747650,-15.743662,1.008872,-0.000540,1.536440
63.747650,15.760216,1.008874,0.000556,1.536350
63.747650,-17.429998,1.007786,-0.000601,1.524926
63.747650,17.440325,1.007792,0.000617,1.524871
66.249077,7.471776,1.015477,0.000199,1.523160
66.249077,-7.505610,1.015326,-0.000216,1.522847
63.747574,-4.134953,0.968982,0.000938,1.516843
66.249077,9.138723,1.014339,0.000323,1.516736
66.249069,-9.175611,1.014277,-0.000326,1.516529
66.249069,-5.818787,1.007672,0.000116,1.515203
63.747578,4.107605,0.967460,-0.000972,1.514502
63.747658,19.098509,1.006855,0.000672,1.512997
66.249069,5.792330,1.005810,-0.000200,1.512456
63.747650,-19.195312,1.006798,-0.000661,1.512278
66.249062,-10.783257,1.012776,-0.000402,1.508884
66.249062,10.811268,1.012771,0.000409,1.508774
56.280674,-0.841660,0.844609,0.001110,1.500542
66.249062,-12.478007,1.011279,-0.000472,1.500104
66.249062,12.503640,1.011275,0.000482,1.499993
56.280682,0.821662,0.843295,-0.001025,1.498215
66.249046,-14.143773,1.009935,-0.000533,1.490854
66.249046,14.165780,1.009932,0.000544,1.490748
66.249046,-15.743661,1.008776,-0.000586,1.481446
66.249046,15.760220,1.008779,0.000597,1.481367
61.238808,2.451035,0.905208,-0.001594,1.476981
61.238808,-2.447977,0.904808,0.001617,1.476330
66.249046,-17.429993,1.007697,-0.000637,1.471014
66.249046,17.440325,1.007704,0.000649,1.470968
68.810837,7.471777,1.015161,0.000303,1.466671
68.810844,-7.505609,1.015041,-0.000315,1.466420
68.810837,9.138728,1.014183,0.000425,1.461042
68.810837,-9.175611,1.014132,-0.000431,1.460867
66.249039,19.098507,1.006765,0.000697,1.460202
66.249046,-19.195309,1.006706,-0.000688,1.459547
68.810867,-5.818785,1.006713,0.000047,1.457812
66.249054,-4.134951,0.967616,0.000932,1.457738
66.249062,4.107605,0.966269,-0.001034,1.455746
68.810875,5.792329,1.004760,-0.000112,1.455029
68.810837,-10.783262,1.012661,-0.000498,1.453916
68.810837,10.811271,1.012648,0.000500,1.453806
68.810837,-12.478012,1.011180,-0.000554,1.445926
68.810837,12.503647,1.011173,0.000559,1.445821
58.725590,-0.841661,0.847190,0.000983,1.442478
58.725586,0.821661,0.845684,-0.000937,1.439921
68.810837,-14.143772,1.009848,-0.000601,1.437518
68.810837,14.165774,1.009841,0.000608,1.437418
68.810837,-15.743662,1.008697,-0.000642,1.428974
68.810837,15.760216,1.008695,0.000650,1.428897
68.810837,-17.429998,1.007627,-0.000681,1.419511
68.810837,17.440325,1.007631,0.000691,1.419467
63.747601,2.451031,0.905247,-0.001438,1.419002
63.747601,-2.447975,0.904859,0.001461,1.418396
68.810837,19.098509,1.006702,0.000729,1.409708
68.810837,-19.195312,1.006633,-0.000721,1.409100
68.810898,-4.134953,0.966344,0.000845,1.401819
68.810898,4.107605,0.965031,-0.000959,1.399948
61.238827,-0.841660,0.849766,0.000815,1.387496
61.238831,0.821662,0.847786,-0.000934,1.384270
66.249123,2.451034,0.905271,-0.001445,1.365533
66.249123,-2.447974,0.904995,0.001364,1.365118
63.747776,-0.841661,0.852150,0.000684,1.336637
63.747791,0.821661,0.849616,-0.000833,1.332667
68.810890,2.451031,0.905297,-0.001391,1.314798
68.810890,-2.447975,0.905186,0.001192,1.314639
66.249222,-0.841661,0.854273,0.000636,1.289381
66.249229,0.821661,0.851372,-0.000811,1.285006
68.810844,-0.841661,0.856309,0.000527,1.244347
68.810837,0.821661,0.853135,-0.000847,1.239738
======================================================
                      TASK 3                          
======================================================
threshold,points,percentage
0.500000,0,0.000000
0.600000,98,0.038153
0.700000,4438,1.727796
0.800000,21088,8.209951
0.900000,66309,25.815331
1.000000,109470,42.618713
1.100000,256859,100.000000
======================================================
                    TASK 4.1                          
======================================================
x,y_h
10.028000,-4.187200
14.958000,-4.819600
20.011999,-5.430400
24.993000,5.634300
29.980000,5.921400
34.987000,-6.197700
39.986000,-6.610100
44.979000,6.633000
49.999001,6.739500
54.983002,6.956200
60.005001,7.066400
65.024002,7.290400
======================================================
                    TASK 4.2                          
======================================================
                                   *
                                 *
                                *
                              *
                             *
                             *
                        *
                      *
                   *
                 *
           *
    *
III
III
III
III
III
    *
           *
                 *
                   *
                      *
                        *
                             *
                             *
                              *
                                *
                                 *
                                   *
======================================================
============================================
src/main.c
12:12:54_Sunday_27_August_2017
============================================
/***************************************************************************
 *
 *   File        : main.c
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <sys/time.h>
#include <string.h>
#include "tasks.h"

/* My BST Library, used for building and searching a balanced BST */
#include "data_handler.h" 

#define NUM_ARGS 3
#define INPUT_INSTRUCTIONS "USAGE EXAMPLE: ./flow flow_data.csv 24"

typedef struct timeval myTime_t;
myTime_t timer_start();
double timer_stop(myTime_t start);

int main(int argc, char *argv[]) {

	// Parse Command Line Arguments
	if (argc != NUM_ARGS) {
		printf(INPUT_INSTRUCTIONS);
		exit(EXIT_FAILURE);
	}
	char* flowFileName = argv[1];
	int gridResolution = atoi(argv[2]);

	// Generate bst
	bst_t* bst = parseFlowFile(flowFileName);
	
	// Task 1: Find the maximum velocity difference
	myTime_t task1_time = timer_start();
	maxveldiff(bst);
	printf("TASK1: %.2lf milliseconds\n", timer_stop(task1_time));

	// Task 2: Coarser Grid
	myTime_t task2_time = timer_start();
	coarsegrid(bst, gridResolution);
	printf("TASK2: %.2lf milliseconds\n", timer_stop(task2_time));

	// Task 3: Statistics
	myTime_t task3_time = timer_start();
	velstat(bst);
	printf("TASK3: %.2lf milliseconds\n", timer_stop(task3_time));

	// Task 4: Wake height and visualisation
	myTime_t task4_time = timer_start();
	wakevis(bst);
	printf("TASK4: %.2lf milliseconds\n", timer_stop(task4_time));

	// free bst
	bst_freeTree(bst);

	return EXIT_SUCCESS;
}

myTime_t timer_start() {
	myTime_t start;
	gettimeofday(&start, NULL);
	return start;
}

double timer_stop(myTime_t start) {
	myTime_t stop;
	gettimeofday(&stop, NULL);
	double elapsed_ms = (stop.tv_sec - start.tv_sec) * 1000.0;
	elapsed_ms += (stop.tv_usec - start.tv_usec) / 1000.0;
	return elapsed_ms;
}
============================================
src/tasks.h
12:12:54_Sunday_27_August_2017
============================================
/***************************************************************************
 *
 *   File        : tasks.h
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/

#include "data_handler.h"

#ifndef TASKS_H
#define TASKS_H

#define T1_CSV "task1.csv"
#define T2_CSV "task2.csv"
#define T3_CSV "task3.csv"
#define T4_1_CSV "task4_1.csv"
#define T4_2_CSV "task4_2.csv"

#define FILE_REWRITE "w"

#define BST_X 0
#define BST_Y 1
#define BST_U 2
#define BST_V 3
#define BST_DIM 4

#define MVD_THRESH 20.0
#define CELL_SCORE_DENOM(x,y) sqrt( x*x + y*y )
#define CELL_SCORE_NUMER(u,v) sqrt( u*u + v*v )
#define CELL_SCORE(x,y,u,v) 100 * (CELL_SCORE_NUMER(u,v)/CELL_SCORE_DENOM(x,y))
#define T2_HEADER "x,y,u,v,S\n"
#define GRID_X_MIN 10.0
#define GRID_X_MAX 70.0
#define GRID_Y_MIN -20.0
#define GRID_Y_MAX 20.0
#define T3_HEADER "threshold,points,percentage\n"
#define T3_INIT_THRESH 0.5
#define T3_THRESH_INTERVAL 0.1
#define T3_PERCENT_END 100.0
#define PERCENT(numer, denom) 100.0*numer/denom
#define T4_HEADER "x,y_h\n"
#define T4_NUM_YS 12
#define T4_INIT_XS 10.0
#define T4_XS_INTERVAL 5.0
#define T4_XS_TOLERANCE 0.05
#define SPACING(y) ceil(10 * fabs(y))


// Cell data type for task 2
typedef struct {
    results_t* points;
    float* av;
    float score;
} cell_t;

// Filter functions used during searching in Task 1
int mvdMaxU(float* d, results_t* res);
int mvdMinU(float* d, results_t* res);
int mvdMaxV(float* d, results_t* res);
int mvdMinV(float* d, results_t* res);

// Used in Task 2
cell_t* generateCell(bst_t* bst, resultsFilter_t* bounds);
void destroyCells(cell_t* cell[], int n);
void destroyCell(cell_t* cell);
// void sortCells(cell_t* cells[], int n);
void printTask2(cell_t* cells[], int n);
int noCheck(float* a, results_t* b);
// void cellSwap(cell_t** cells, int a, int b);
// void cellQsort(cell_t* cells[], int left, int right);
// int cellPartition(cell_t* cells[], int left, int right);
int cellCmp(const void* a, const void* b);

// Used in Task 4
float* getYs_t4(bst_t* bst);

// Task functions
void maxveldiff(bst_t* bst);
void coarsegrid(bst_t* bst, int resolution);
void velstat(bst_t* bst);
void wakevis(bst_t* bst);

#endif
============================================
src/data_handler.c
12:12:54_Sunday_27_August_2017
============================================
/***************************************************************************
 *
 *   File        : data_handler.c
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <float.h>
#include <string.h>
#include <assert.h>
#include "data_handler.h"

/* * * * * * * * * * * * * * * * * * * * * * *  PRIVATE FUNCTION DECLARATIONS */

// Private functions don't need to be visible to programs outside this file

// Funcions dealing with nodes rather than data
static node_t* bst_newNode(int dim, float* data);
static void bst_freeNode(node_t* node);

// BST balancing functions
static void bst_balance( bst_t* bst, node_t* node_a, int dataIndex);
static node_t* bst_leftOuterRot(bst_t* bst, node_t* node_a, int dataIndex);
static node_t* bst_rightOuterRot(bst_t* bst, node_t* node_a, int dataIndex);
static node_t* bst_leftInnerRot(bst_t* bst, node_t* node_a, int dataIndex);
static node_t* bst_rightInnerRot(bst_t* bst, node_t* node_a, int dataIndex);
static int node_maxDepth(node_t* node, int dataIndex);
static void fixParentDepth(bst_t* bst, node_t* node_a, int dataIndex);

// Recursive helper functions
static int bst_printTree_Rec( node_t* n, int dataIndex, int dim, FILE* stream);
static int bst_freeTree_Rec(bst_t* bst, node_t* root, int dataIndex);
static void bst_insertNode_Rec(bst_t* bst, node_t* root, node_t* newNode, int dataIndex);

// Helper search functions
static void bst_search_Rec(node_t* node, results_t *f, int t);
static void res_insert(results_t* res, float* d);





/* * * * * * * * * * * * * * * * * * * * * * * * * * * * *  PARSING FUNCTIONS */

// Returns bst containing data from the flow file
bst_t* parseFlowFile(char *filename) {

	assert(filename!=NULL);
	
	FILE* fp = fopen(filename, FILE_READ);
	assert(fp != NULL);
	
	bst_t* bst = parseFlowFileFirstLine(fp);
	while (parseFlowFileDataLine(bst, fp) != PARSE_DONE) {
	}

	fclose(fp);

	return bst;
}

// Parses first line of flow file to get:
//  1. key (eg: {'x','y','u','v'}) and
//  2. number of dimensions (eg: 4 data entries for each line in the csv)
// Uses the key and number of dimensions to generate an empty bst
bst_t* parseFlowFileFirstLine(FILE* fp) {
	
	assert(fp!=NULL);

	char* key = (char* )malloc( sizeof(char) );
	assert(key != NULL);

	char tmpc;
	int i = 0;
	while (1) {

		tmpc = fgetc(fp);
		if (tmpc == CSV_COMMA) { continue; }
		if (tmpc == CSV_NEWLINE) { break; }

		key = (char*)realloc( key, (i+2) * sizeof(char) );
		assert(key != NULL);
		key[i] = tmpc;
		i++;
	}

	return bst_newTree(i, key);
}

// Parses a data entry from flow file, inserts it into bst
int parseFlowFileDataLine(bst_t* bst, FILE* fp) {

	assert(bst!=NULL);
	assert(fp!=NULL);
	
	// Store the data in an array d
	float* data = (float*)malloc(bst->dim*sizeof(float));
	assert(data != NULL);
	
	// Read the line into array d
	int i = 0, read=0;
	for (i=0; i < bst->dim; i++) {
		read += fscanf(fp, "%f,", &(data[i]) );
	}

	// Decide whether to insert data, finish parsing, or detect an error
	char endCheck = fgetc(fp);
	if ( read==(bst->dim) && endCheck == CSV_NEWLINE) {
		bst_insertData(bst, data);
		return !PARSE_DONE;
	} else if ( endCheck == EOF) {
		free(data);
		return PARSE_DONE;
	} else {
		printf("ERROR: File parsing failed, exiting...");
		exit(EXIT_FAILURE);
	}
}




/* * * * * * * * * * * * * * * * * * * * * * *  PUBLIC BST AND DATA FUNCTIONS */

// Generate a new empty bst
bst_t* bst_newTree(int dim, char* key) {

	assert(key!=NULL);
	
	bst_t* bst = (bst_t*)malloc(sizeof(bst_t));
	assert(bst != NULL);

	bst->root = (node_t**)calloc( dim , sizeof(node_t*) );
	assert(bst->root != NULL);

	bst->numNodes = 0;
	bst->dim = dim;
	bst->key = key;

	return bst;
}

// Frees memory associated with a tree, including the data contained in the tree
int bst_freeTree(bst_t* bst) {

	assert(bst!=NULL);

	int freed = bst_freeTree_Rec(bst, bst->root[BST_INDEX], BST_INDEX);
	assert(bst->numNodes == 0);
	free(bst->root);
	free(bst->key);
	free(bst);

	return freed;
}

// Inserts a data array into the bst as a node
void bst_insertData(bst_t* bst, float* data) {
	
	assert(bst!=NULL);
	assert(data!=NULL);

	node_t* newNode = bst_newNode(bst->dim, data);
	
	int i=0;
	for (i=0; i<bst->dim; i++) {
		if (bst->root[i] == NULL) {
			bst->root[i] = newNode;
		} else {
			bst_insertNode_Rec(bst, bst->root[i],newNode,i);
		}
	}
	bst->numNodes++;
}

// Prints the key of the bst 
void bst_printKey(bst_t* bst, FILE* stream) {
	
	assert(bst!=NULL);

	int i = 0;
	for (i=0; i < bst->dim; i++) {
		fprintf(stream, "%c", bst->key[i] );
		if (i < bst->dim-1) { fprintf(stream, ","); }
	}
	fprintf(stream, "\n");
}

// Prints all of the items in order of low to high
int bst_printTree(bst_t* bst, int dataIndex, FILE* stream) {

	assert(bst!=NULL);
	assert(dataIndex < bst->dim);

	bst_printKey(bst, stream);	
	return bst_printTree_Rec(bst->root[dataIndex], dataIndex, bst->dim, stream);
}

// Prints a data entry
void bst_printData(int dim, float* data, FILE* stream) {

	assert(data!=NULL);

	int i = 0;
	for (i=0; i < dim; i++) {
		fprintf(stream, "%.6f", data[i] );
		if (i < dim-1) { fprintf(stream, ",");}
	}
	fprintf(stream, "\n");
}

// Searches a bst for data entries beween lo and hi
// The check function must return 1 or 0 to insert or not insert an item
// The check function can also modify the results since it has access to them
results_t* res_search(
	bst_t* bst, resultsFilter_t* filter, int (*check)(float*, results_t*) ) {

	assert(check!=NULL);
	assert(filter!=NULL);
	assert(bst != NULL);

	float** arr = (float**)calloc(RESULTS_LEN, sizeof(float*));
	assert(arr!=NULL);

	results_t* res = (results_t*)malloc(sizeof(results_t));
	assert(res!=NULL);

	res->arrLen = RESULTS_LEN;
	res->numEl = 0;
	res->dim = bst->dim;
	res->filter = filter;
	res->check = check;
	res->arr = arr;

	// Determine best filter to apply (the one with the most narrow bounds)
	float minDiff=FLT_MAX;
	int i=0, t=0;
	for (i=0; i<bst->dim; i++) {
		if ((res->filter[i].hi - res->filter[i].lo) < minDiff ) {
			minDiff = res->filter[i].hi - res->filter[i].lo;
			t = i;
		}
	}
	bst_search_Rec(bst->root[t],res,t);

	return res;
}

// Frees a results structure
void res_free(results_t* res) {
	free(res->arr);
	free(res);
}




/* * * * * * * * * * * * * * * * * * * * * * * * * * * * *  PRIVATE FUNCTIONS */

// Generates a new node
static node_t* bst_newNode(int dim, float* data) {
	
	assert(data != NULL);
	assert(dim>0);

	node_t* newNode = (node_t*)malloc(sizeof(node_t));
	newNode->d = data;
	newNode->depth_R = (int*)calloc(dim, sizeof(int*));
	newNode->depth_L = (int*)calloc(dim, sizeof(int*));
	newNode->left = (node_t**)calloc(dim, sizeof(node_t*));
	newNode->right = (node_t**)calloc(dim, sizeof(node_t*));
	newNode->parent = (node_t**)calloc(dim, sizeof(node_t*));

	assert(newNode != NULL);
	assert(newNode->depth_R != NULL);
	assert(newNode->depth_L != NULL);
	assert(newNode->left != NULL);
	assert(newNode->right != NULL);
	assert(newNode->parent != NULL);

	return newNode;
}

// Frees a node
static void bst_freeNode(node_t* node) {

	assert(node != NULL);
	assert(node->left != NULL);
	assert(node->right != NULL);
	assert(node->d != NULL);

	free(node->d);
	free(node->depth_R);
	free(node->depth_L);
	free(node->right);
	free(node->left);
	free(node->parent);
	free(node);
}

// Iteratively insert a node into a bst
static void bst_insertNode_Rec(bst_t* bst, node_t* root, node_t* newNode, int dataIndex) {
	
	assert(newNode != NULL);
	assert(root != NULL);
	assert(bst != NULL);

	if (newNode->d[dataIndex] < root->d[dataIndex]) {

		root->depth_L[dataIndex]++;
		if (root->left[dataIndex] == NULL) {
			root->left[dataIndex] = newNode;
			newNode->parent[dataIndex] = root;
			bst_balance(bst, root, dataIndex);
		} else {
			bst_insertNode_Rec(bst, root->left[dataIndex],newNode,dataIndex);
		}
	} else {
		root->depth_R[dataIndex]++;
		if (root->right[dataIndex] == NULL) {
			root->right[dataIndex] = newNode;
			newNode->parent[dataIndex] = root;
		} else {
			bst_insertNode_Rec(bst, root->right[dataIndex],newNode,dataIndex);
		}
	}
	bst_balance(bst, root, dataIndex);
}

// Recursively print tree (in order traverse), returns number of items printed
static int bst_printTree_Rec(node_t* n, int dataIndex, int dim, FILE* stream) {

	assert(dataIndex < dim);

	int numPrinted = 0;

	if (n!=NULL) {

		node_t* left = n->left[dataIndex];
		node_t* right = n->right[dataIndex];
		numPrinted=1;

		numPrinted += bst_printTree_Rec(left, dataIndex, dim, stream);
		bst_printData(dim, n->d, stream);
		numPrinted += bst_printTree_Rec(right, dataIndex, dim, stream);
	}
	return numPrinted;
}

// Recursively free a tree (post order traverse), returns number of items freed
static int bst_freeTree_Rec(bst_t* bst, node_t* root, int dataIndex) {

	int numFreed = 0;
	if (root!=NULL) {
		numFreed++;
		numFreed += bst_freeTree_Rec(bst, root->left[dataIndex], dataIndex);
		numFreed += bst_freeTree_Rec(bst, root->right[dataIndex], dataIndex);
		bst_freeNode(root);
		bst->numNodes--;
	}
	return numFreed;
}

// Recursively search the tree
static void bst_search_Rec(node_t* node, results_t *f, int t) {
	
	assert(f!=NULL);
	assert(t < f->dim);

	if ( node != NULL ) {

		int aboveUpper=0, belowLower=0, inBetween=0;
		
		aboveUpper = node->d[t] > f->filter[t].hi;
		belowLower = node->d[t] < f->filter[t].lo;
		inBetween = (aboveUpper == 0) && (belowLower == 0);

		if ( aboveUpper ) {
			bst_search_Rec(node->left[t],  f, t);
		}

		if ( belowLower ) {
			bst_search_Rec(node->right[t],  f, t);
		}

		if ( inBetween ) {
			bst_search_Rec(node->left[t],  f, t);
			res_insert(f, node->d);
			bst_search_Rec(node->right[t],  f, t);
		}
	}
}

// Inserts a data entry into a results structure
// (provided it is within the bounds)
static void res_insert(results_t* res, float* d) {

	// check that item is insertable
	int insert = 1, lessThanLo = 0, moreThanHi = 0;
	int i=0;
	for (i=0;i<res->dim;i++) {

		lessThanLo = d[i] < (res->filter[i]).lo;
		moreThanHi = d[i] > (res->filter[i]).hi;

		if (lessThanLo || moreThanHi ) {
			insert = 0;
		}
	}

	if(insert && res->check(d,res)) {

		// Extend array if necessary
		if (res->numEl >= res->arrLen) {
			res->arrLen += RESULTS_LEN;
			res->arr = (float**)realloc(res->arr, res->arrLen * sizeof(float*));
			assert(res->arr != NULL);
		}

		res->arr[res->numEl] = d;
		res->numEl++;
	}
}






/* * * * * * * * * * * * * * * * * * * * * * *  PRIVATE FUNCTIONS (BALANCING) */

// Correct imbalances in the tree
static void bst_balance( bst_t*bst, node_t* node_a, int dataIndex ) {

	assert(bst != NULL);
	assert(node_a != NULL);

	int a_depDiff = node_a->depth_R[dataIndex] - node_a->depth_L[dataIndex];
	int r_depDiff = 0;
	int l_depDiff = 0;

	if ( a_depDiff >= BST_BALANCE_THRESH ) {

		assert(node_a->right[dataIndex] != NULL);
		r_depDiff = node_a->right[dataIndex]->depth_R[dataIndex]
												- node_a->depth_L[dataIndex];
		if ( r_depDiff > 0) {
			bst_rightOuterRot(bst, node_a, dataIndex);
		} else {
			bst_rightInnerRot(bst, node_a, dataIndex);
		}

	} else if ( a_depDiff <= -BST_BALANCE_THRESH){

		assert(node_a->left[dataIndex] != NULL);
		l_depDiff = node_a->left[dataIndex]->depth_R[dataIndex]
												- node_a->depth_L[dataIndex];
		if ( l_depDiff < 0) {
			bst_leftOuterRot(bst, node_a, dataIndex);
		} else {
			bst_leftInnerRot(bst, node_a, dataIndex);
		}
	}
}

// Left outer rotation balancing
static node_t* bst_leftOuterRot(bst_t* bst, node_t* node_a, int dataIndex) {

	assert(bst != NULL);
	assert(node_a!=NULL);
	assert(node_a->left[dataIndex]!=NULL);
	node_t* node_b = node_a->left[dataIndex];
	node_t* parent = node_a->parent[dataIndex];

	// a.left points to b.right
	if (node_b->right[dataIndex] != NULL) {
		node_a->left[dataIndex] = node_b->right[dataIndex];
		node_a->left[dataIndex]->parent[dataIndex] = node_a;
		node_a->depth_L[dataIndex] = 1 + node_maxDepth(node_a->left[dataIndex], dataIndex);
	} else {
		node_a->left[dataIndex] = NULL;
		node_a->depth_L[dataIndex] = 0;
	}
	
	// b.right points to a
	node_b->right[dataIndex] = node_a;
	node_b->right[dataIndex]->parent[dataIndex] = node_b;
	node_b->depth_R[dataIndex] = 1 + node_maxDepth(node_b->right[dataIndex], dataIndex);
	
	// parent now points to b
	if (parent != NULL) {
		if (parent->left[dataIndex] == node_a) {
			parent->left[dataIndex] = node_b;
			node_b->parent[dataIndex] = parent;
		} else if (parent->right[dataIndex] == node_a) {
			parent->right[dataIndex] = node_b;
			node_b->parent[dataIndex] = parent;
		} else {
			exit(EXIT_FAILURE);
		}
	} else { // must account for when node_a is the bst root and parent==NULL
		bst->root[dataIndex] = node_b;
		node_b->parent[dataIndex] = NULL;
	}
	fixParentDepth(bst, node_b, dataIndex);
	return node_b;
}

// Right outer rotation balancing
static node_t* bst_rightOuterRot(bst_t* bst, node_t* node_a, int dataIndex) {
	
	assert(bst != NULL);
	assert(node_a!=NULL);
	assert(node_a->right[dataIndex]!=NULL);
	node_t* node_b = node_a->right[dataIndex];
	node_t* parent = node_a->parent[dataIndex];

	// a.right points to b.left
	if (node_b->left[dataIndex]!= NULL) {
		node_a->right[dataIndex] = node_b->left[dataIndex];
		(node_a->right[dataIndex])->parent[dataIndex] = node_a;
		node_a->depth_R[dataIndex] = 1 + node_maxDepth(node_a->right[dataIndex], dataIndex);
	} else {
		node_a->right[dataIndex] = NULL;
		node_a->depth_R[dataIndex] = 0;
	}
	
	// b.left points to a
	node_b->left[dataIndex] = node_a;
	(node_b->left[dataIndex])->parent[dataIndex] = node_b;
	node_b->depth_L[dataIndex] = 1 + node_maxDepth(node_b->left[dataIndex], dataIndex);
	
	// parent now points to b
	if (parent != NULL) {
		if (parent->right[dataIndex] == node_a) {
			parent->right[dataIndex] = node_b;
			node_b->parent[dataIndex] = parent;
		} else if (parent->left[dataIndex] == node_a) {
			parent->left[dataIndex] = node_b;
			node_b->parent[dataIndex] = parent;
		} else {
			exit(EXIT_FAILURE);
		}
	} else { // must account for when node_a is the bst root and parent==NULL
		bst->root[dataIndex] = node_b;
		node_b->parent[dataIndex] = NULL;
	}
	fixParentDepth(bst, node_b, dataIndex);
	return node_b;
}

// Left inner rotation balancing
static node_t* bst_leftInnerRot( bst_t* bst, node_t* a, int dataIndex){

	assert(a!=NULL);
	assert(bst != NULL);

	node_t* b = a->left[dataIndex];
	assert(b!=NULL);
	node_t* c = b->right[dataIndex];
	assert(c!=NULL);
	node_t* parent = a->parent[dataIndex];
	
	// a.left points to c.right
	if (c->right[dataIndex] != NULL) {
		a->left[dataIndex] = c->right[dataIndex];
		a->left[dataIndex]->parent[dataIndex] = a;
		a->depth_L[dataIndex] = 1 + node_maxDepth(a->left[dataIndex], dataIndex);
	} else {
		a->left[dataIndex] = NULL;
		a->depth_L[dataIndex] = 0;
	}
	
	// b.right points to c.left
	if (c->left[dataIndex] != NULL) {
		b->right[dataIndex] = c->left[dataIndex];
		b->right[dataIndex]->parent[dataIndex] = b;
		b->depth_R[dataIndex] = 1 + node_maxDepth(b->right[dataIndex], dataIndex);
	} else {
		b->right[dataIndex] = NULL;
		b->depth_R[dataIndex] = 0;
	}

	// c.left points to b
	c->left[dataIndex] = b;
	c->left[dataIndex]->parent[dataIndex] = b;
	c->depth_L[dataIndex] = 1 + node_maxDepth(c->left[dataIndex], dataIndex);
	
	// c.right points to a
	c->right[dataIndex] = a;
	c->right[dataIndex]->parent[dataIndex] = a;
	c->depth_R[dataIndex] = 1 + node_maxDepth(c->right[dataIndex], dataIndex);
	
	// parent now points to c
	if (parent != NULL) {
		if (parent->left[dataIndex] == a) {
			parent->left[dataIndex] = c;
			c->parent[dataIndex] = parent;
		} else if (parent->right[dataIndex] == a) {
			parent->right[dataIndex] = c;
			c->parent[dataIndex] = parent;
		} else {
			exit(EXIT_FAILURE);
		}
	} else { // must account for when node_a is the bst root and parent==NULL
		bst->root[dataIndex] = c;
		c->parent[dataIndex] = NULL;
	}
	fixParentDepth(bst, c, dataIndex);
	return c;
}

// Right inner rotation balancing
static node_t* bst_rightInnerRot( bst_t* bst, node_t* a, int dataIndex){

	assert(a!=NULL);
	assert(bst != NULL);

	node_t* b = a->right[dataIndex];
	assert(b!=NULL);
	node_t* c = b->left[dataIndex];
	assert(c!=NULL);
	node_t* parent = a->parent[dataIndex];
	
	// a.right points to c.left
	if (c->left[dataIndex] != NULL) {
		a->right[dataIndex] = c->left[dataIndex];
		a->right[dataIndex]->parent[dataIndex] = a;
		a->depth_R[dataIndex] = 1 + node_maxDepth(a->right[dataIndex], dataIndex);
	} else {
		a->right[dataIndex] = NULL;
		a->depth_R[dataIndex] = 0;
	}
	
	// b.left points to c.right
	if (c->right[dataIndex] != NULL) {
		b->left[dataIndex] = c->right[dataIndex];
		b->left[dataIndex]->parent[dataIndex] = b;
		b->depth_L[dataIndex] = 1 + node_maxDepth(b->left[dataIndex], dataIndex);
	} else {
		b->left[dataIndex] = NULL;
		b->depth_L[dataIndex] = 0;
	}

	// c.left points to a
	c->left[dataIndex] = a;
	c->left[dataIndex]->parent[dataIndex] = c;
	c->depth_L[dataIndex] = 1 + node_maxDepth(c->left[dataIndex], dataIndex);
	
	// c.right points to b
	c->right[dataIndex] = b;
	c->right[dataIndex]->parent[dataIndex] = c;
	c->depth_R[dataIndex] = 1 + node_maxDepth(c->right[dataIndex], dataIndex);
	
	
	// parent now points to c
	if (parent != NULL) {
		if (parent->left[dataIndex] == a) {
			parent->left[dataIndex] = c;
			c->parent[dataIndex] = parent;
		} else if (parent->right[dataIndex] == a) {
			parent->right[dataIndex] = c;
			c->parent[dataIndex] = parent;
		} else {
			exit(EXIT_FAILURE);
		}
		
	} else { // must account for when node_a is the bst root and parent==NULL
		bst->root[dataIndex] = c;
		c->parent[dataIndex] = NULL;
	}
	fixParentDepth(bst, c, dataIndex);
	return c;
}

// Returns the maximum depth of the left and right branches
static int node_maxDepth(node_t* node, int dataIndex) {
	return MAX(node->depth_L[dataIndex], node->depth_R[dataIndex]);
}

// Propogates a change in depth up the tree
static void fixParentDepth(bst_t* bst, node_t* node_a, int dataIndex) {
	
	node_t* parent = node_a->parent[dataIndex];
	node_t* next = node_a;

	while (parent!=NULL) {

		if (parent->left[dataIndex] == next) {
			parent->depth_L[dataIndex] = 1 + node_maxDepth(next, dataIndex);
		} else if (parent->right[dataIndex] == next) {
			parent->depth_R[dataIndex] = 1 + node_maxDepth(next, dataIndex);
		} else {
			printf("The tree is broken!\n");
			exit(EXIT_FAILURE);
		}
		next = parent;
		parent = parent->parent[dataIndex];
	}
}
============================================
src/tasks.c
12:12:54_Sunday_27_August_2017
============================================
/***************************************************************************
 *
 *   File        : tasks.c
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <float.h>
#include <sys/time.h>
#include <string.h>
#include <assert.h>
#include "tasks.h"
#include "data_handler.h"

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * TASK FUNCTIONS */

void maxveldiff(bst_t* bst) {
	assert(bst!=NULL);

	FILE* fp = fopen(T1_CSV, FILE_REWRITE);
	assert(fp!=NULL);

	// search for max/min
	resultsFilter_t searchFilter[] = {
		{MVD_THRESH, FLT_MAX},
		{-FLT_MAX, FLT_MAX},
		{-FLT_MAX, FLT_MAX},
		{-FLT_MAX, FLT_MAX}
	};

	results_t* maxU = res_search(bst, searchFilter, mvdMaxU);
	results_t* minU = res_search(bst, searchFilter, mvdMinU);
	results_t* maxV = res_search(bst, searchFilter, mvdMaxV);
	results_t* minV = res_search(bst, searchFilter, mvdMinV);

	// print max/min
	bst_printKey(bst, fp);
	bst_printData(bst->dim, maxU->arr[0], fp);
	bst_printData(bst->dim, minU->arr[0], fp);
	bst_printData(bst->dim, maxV->arr[0], fp);
	bst_printData(bst->dim, minV->arr[0], fp);

	// free results structures
	res_free(minU);
	res_free(maxU);
	res_free(minV);
	res_free(maxV);

	fflush(fp);
	fclose(fp);
}

void coarsegrid(bst_t* bst, int resolution) {

	assert(bst!=NULL);

	cell_t* cells[resolution*resolution];
	cell_t* tmpCell = NULL;

	resultsFilter_t bound[] = {
		{-FLT_MAX, FLT_MAX},
		{-FLT_MAX, FLT_MAX},
		{-FLT_MAX, FLT_MAX},
		{-FLT_MAX, FLT_MAX}
	};

	float delta_x = (GRID_X_MAX - GRID_X_MIN) / resolution;
	float delta_y = (GRID_Y_MAX - GRID_Y_MIN) / resolution;

	int x_i=0, y_i=0, cell_i=0;
	for ( x_i=0 ; x_i<resolution ; x_i++ ) {
		for ( y_i=0 ; y_i<resolution ; y_i++ ) {

			// generate bounds for search
			bound[BST_X].lo = GRID_X_MIN + x_i*delta_x;
			bound[BST_X].hi = bound[BST_X].lo + delta_x;
			bound[BST_Y].lo = GRID_Y_MIN + y_i*delta_y;
			bound[BST_Y].hi = bound[BST_Y].lo+ delta_y;

			// search and generate cells
			tmpCell = generateCell(bst, bound);
			if (tmpCell != NULL) {
				cells[cell_i] = tmpCell;
				cell_i++;
			}
		}
	}

	// sort, print, free memory
	qsort(cells, cell_i, sizeof(cell_t*), cellCmp);
	printTask2(cells, cell_i);
	destroyCells(cells, cell_i);
}

void velstat(bst_t* bst) {

	assert(bst!=NULL);

	FILE* fp = fopen(T3_CSV, FILE_REWRITE);
	assert(fp!=NULL);
	fprintf(fp, T3_HEADER);

	float thresh = T3_INIT_THRESH;
	float percent = 0;
	int totalPoints = bst->numNodes;
	int numPointsFound = 0;
	
	while(percent<T3_PERCENT_END) {

		resultsFilter_t searchFilter[] = {
			{-FLT_MAX, FLT_MAX},
			{-FLT_MAX, FLT_MAX},
			{-FLT_MAX, thresh},
			{-FLT_MAX, FLT_MAX}
		};

		results_t* res = res_search(bst, searchFilter, noCheck);
		numPointsFound = res->numEl;
		res_free(res);
		percent = PERCENT(numPointsFound, totalPoints);
		fprintf(fp,"%.6f,%d,%.6f\n", thresh, numPointsFound, percent);
		thresh = thresh + T3_THRESH_INTERVAL;
	}

	fflush(fp);
	fclose(fp);
}

void wakevis(bst_t* bst) {

	// get spacing
	float* yheight = getYs_t4(bst);

	// Print wake profile using given skeleton
	int i,j;
	FILE *ft42;
	ft42 = fopen("task4_2.txt","w");
	for (j = 11; j>=0; j--){
	for (i=0;i<yheight[j]-yheight[0]+4;i++){
 		fprintf(ft42, " ");
	}
		fprintf(ft42, "*\n");
	}
	for (i=0;i<5; i++){
		fprintf(ft42, "III\n");
	}
	for(j = 0; j<12; j++ ){
		for (i=0;i<yheight[j]-yheight[0]+4;i++){
			fprintf(ft42, " ");
		}
		fprintf(ft42, "*\n");
	}
	fclose(ft42);

	/* Cleanup */
	free(yheight);
}




/* * * * * * * * * * * * * * * * * * * * * * * * * *  TASK 1 HELPER FUNCTIONS */
// These functions are called by the bst search function to decide when to
// insert items into the search array. They are used in task 1 to replace 
// previous results so that the correct maximum/minimum is found

int mvdMaxU(float* d, results_t* res) {
	
	assert(res->numEl == 1 || res->numEl == 0);
	
	if (res->numEl == 0) {
		return 1; // insert item if it's the first result
	} else if (res->numEl == 1) {

		if (d[BST_U] > res->arr[0][BST_U]) { // found a new maximum U
			res->arr[0] = d; // replace previous result
		} else if (
			(d[BST_U] == res->arr[0][BST_U]) && // same maximum U
			(d[BST_X] < res->arr[0][BST_X])		// earlier in the domain X
		) {
			res->arr[0] = d; // replace previous result
		} else if (
			(d[BST_U] == res->arr[0][BST_U]) && // same maximum U
			(d[BST_X] == res->arr[0][BST_X]) && // same domain X
			(d[BST_Y] < res->arr[0][BST_Y])		// lower Y
		) {
			res->arr[0] = d; // replace previous result
		}
		return 0;

	}
	exit(EXIT_FAILURE);
}

int mvdMinU(float* d, results_t* res) {
	
	assert(res->numEl <= 1 && res->numEl >= 0);

	if (res->numEl == 0) {
		return 1; // insert item if it's the first result
	} else if (res->numEl == 1) {

		if ( d[BST_U] < res->arr[0][BST_U] ) { // new min U found
			res->arr[0] = d; // replace item
		} else if ( 
			( d[BST_U] == res->arr[0][BST_U] ) && 	// same U
			( d[BST_X] < res->arr[0][BST_X] ) 		// earlier in domain X
		) {
			res->arr[0] = d; // replace item
		} else if (
			( d[BST_U] == res->arr[0][BST_U] ) && 	// same U
			( d[BST_X] == res->arr[0][BST_X] ) &&	// same domain X
			( d[BST_Y] < res->arr[0][BST_Y] )		// lower domain Y
		) {
			res->arr[0] = d; // replace item
		}
		return 0;
	}
	exit(EXIT_FAILURE);
}

int mvdMaxV(float* d, results_t* res) {
	
	assert(res->numEl <= 1 && res->numEl >= 0);

	if (res->numEl == 0) {
		return 1; // insert item if it's the first result
	} else if (res->numEl == 1) {
		
		if ( d[BST_V] > res->arr[0][BST_V] ) { // new max X found
			res->arr[0] = d; // replace item
		} else if ( 
			( d[BST_V] == res->arr[0][BST_V] ) && 	// same V
			( d[BST_X] < res->arr[0][BST_X] ) 		// earlier in domain X
		) {
			res->arr[0] = d; // replace item
		} else if (
			( d[BST_V] == res->arr[0][BST_V] ) && 	// same V
			( d[BST_X] == res->arr[0][BST_X] ) &&	// same domain X
			( d[BST_Y] < res->arr[0][BST_Y] )		// lower domain Y
		) {
			res->arr[0] = d; // replace item
		}

		return 0;
	}
	exit(EXIT_FAILURE);
}

int mvdMinV(float* d, results_t* res) {
	
	assert(res->numEl <= 1 && res->numEl >= 0);

	if (res->numEl == 0) {
		return 1; // insert item if it's the first result
	} else if (res->numEl == 1) {
		
		if ( d[BST_V] < res->arr[0][BST_V] ) { // new min V found
			res->arr[0] = d; // replace item
		} else if ( 
			( d[BST_V] == res->arr[0][BST_V] ) && 	// same V
			( d[BST_X] < res->arr[0][BST_X] ) 		// earlier in domain X
		) {
			res->arr[0] = d; // replace item
		} else if (
			( d[BST_V] == res->arr[0][BST_V] ) && 	// same V
			( d[BST_X] == res->arr[0][BST_X] ) &&	// same domain X
			( d[BST_Y] < res->arr[0][BST_Y] )		// lower domain Y
		) {
			res->arr[0] = d; // replace item
		}

		return 0;
	}
	exit(EXIT_FAILURE);
}




/* * * * * * * * * * * * * * * * * * * * * * * * * *  TASK 2 HELPER FUNCTIONS */

// Generates a new cell struct for task 2
cell_t* generateCell(bst_t* bst, resultsFilter_t* bounds){

	assert(bst!=NULL);
	assert(bounds!=NULL);
	cell_t* cell = (cell_t*)malloc(sizeof(cell_t));
	assert(cell != NULL);

	// Get points by searching the tree
	cell->points = res_search(bst, bounds, noCheck);
		
	// Calculate average and score if there were results found, else return null
	float* sum = (float*)calloc(bst->dim, sizeof(float));
	assert(sum!=NULL);
	cell->av = sum;

	if ((cell->points)->numEl != 0) {

		// Calculate average
		int i=0, dataIndex = 0;
		for ( dataIndex=0; dataIndex<bst->dim; dataIndex++ ) {
			for ( i=0; i<(cell->points)->numEl; i++ ) {
				sum[dataIndex] += (cell->points)->arr[i][dataIndex];
			}
			cell->av[dataIndex] = sum[dataIndex]/(cell->points)->numEl;
		}

		// Calculate score
		cell->score = CELL_SCORE( 
			cell->av[BST_X], cell->av[BST_Y], cell->av[BST_U], cell->av[BST_V] 
		);

		return cell;
	} else {
		destroyCell(cell);
		return NULL;
	}
}

// frees a list of cells
void destroyCells(cell_t* cell[], int n) {

	assert(cell!=NULL);

	int i=0;
	for (i=0;i<n;i++) { 
		if (cell[i]!=NULL) { destroyCell(cell[i]); };
	}
}

// frees memory associated with a cell
void destroyCell(cell_t* cell) {
	
	assert(cell!=NULL);
	res_free(cell->points);
	free(cell->av);
	free(cell);
}

// Prints the output of task 2
void printTask2(cell_t* cells[], int n) {
	assert(cells != NULL);

	FILE* fp = fopen(T2_CSV,FILE_REWRITE);

	fprintf(fp, T2_HEADER);

	int i=0;
	for (i=0;i<n;i++) {
		fprintf(fp, "%.6f,%.6f,%.6f,%.6f,%.6f\n",
			cells[i]->av[BST_X],
			cells[i]->av[BST_Y],
			cells[i]->av[BST_U],
			cells[i]->av[BST_V],
			cells[i]->score
			);
	}
	
	fflush(fp);
	fclose(fp);
}

// Check function used to determine if an item should be inserted, returns 1
// since we only care about whether the item is within the bounds, which is
// checked during search in data_handler.c - res_insert(..)
int noCheck(float* a, results_t* b) {
	return 1;
}

// Comparison function used to qsort cells by their score
int cellCmp(const void* a, const void* b) {

	float a_s = (*(cell_t**)a)->score;
	float b_s = (*(cell_t**)b)->score;

	return (a_s < b_s) - (a_s > b_s);
}




/* * * * * * * * * * * * * * * * * * * * * * * * * *  TASK 4 HELPER FUNCTIONS */

float* getYs_t4(bst_t* bst) {

	assert(bst!=NULL);

	FILE* fp = fopen(T4_1_CSV, FILE_REWRITE);
	assert(fp!=NULL);
	fprintf(fp, T4_HEADER);

	float* ys = (float*)calloc(T4_NUM_YS,sizeof(float));
	assert(ys!=NULL);

	resultsFilter_t bound[] = {
		{-FLT_MAX, FLT_MAX},
		{-FLT_MAX, FLT_MAX},
		{-FLT_MAX, FLT_MAX},
		{-FLT_MAX, FLT_MAX}
	};

	int i=0;
	float xVal = 0;
	for (i=0; i<T4_NUM_YS; i++) {

		xVal = i*T4_XS_INTERVAL + T4_INIT_XS;
		bound[BST_X].lo = xVal - T4_XS_TOLERANCE;
		bound[BST_X].hi = xVal + T4_XS_TOLERANCE;
		
		results_t* res = res_search(bst, bound, mvdMaxU);
		if (res->numEl == 1) {
			ys[i] = SPACING( (res->arr[0])[BST_Y] );
			fprintf(fp, "%.6f,%.6f\n",
				(res->arr[0])[BST_X],
				(res->arr[0])[BST_Y]);
			res_free(res);
		}
	}

	fflush(fp);
	fclose(fp);
	return ys;
}============================================
src/data_handler.h
12:12:54_Sunday_27_August_2017
============================================
/***************************************************************************
 *
 *   File        : data_handler.h
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/
#include <stdio.h>

#ifndef DATA_HANDLER_H
#define DATA_HANDLER_H

#define FILE_READ "r"
#define PARSE_DONE 1
#define CSV_NEWLINE '\n'
#define CSV_COMMA ','
#define BST_INDEX 0
#define BST_BALANCE_THRESH 2
#define RESULTS_LEN 128
#define MAX(a, b) (((a) > (b)) ? (a) : (b))

/* node type */
typedef struct NodeStruct node_t;
struct NodeStruct {
    float* d;
    int* depth_L;
    int* depth_R;
    node_t** parent;
    node_t** left;
    node_t** right;
};

/* bst type */
typedef struct {
    int numNodes;
    int dim;
    node_t** root;
    char* key;
} bst_t;

/* Results type */
// check function returns 1 when a new data point should be inserted into the
// results.

typedef struct {
    float lo, hi;
} resultsFilter_t;

typedef struct ResultsStruct results_t;
struct ResultsStruct {
    int arrLen, numEl;
    int dim;
    resultsFilter_t* filter;
    int (*check)(float*, results_t*);
	float** arr;
};

// parse flow file
bst_t* parseFlowFile(char* filename);
bst_t* parseFlowFileFirstLine(FILE* fp);
int parseFlowFileDataLine(bst_t* bst, FILE* fp);

// build a tree
bst_t* bst_newTree(int dim, char* key);
void bst_insertData(bst_t* bst, float* data);
int bst_freeTree(bst_t* bst);

// print data
void bst_printKey(bst_t* bst, FILE* stream);
void bst_printData(int dim, float* data, FILE* stream);
int bst_printTree(bst_t* bst, int dataIndex, FILE* stream);

// search the tree
results_t* res_search(
    bst_t* bst, resultsFilter_t* filter, int (*check)(float*, results_t*));

void res_free(results_t* res);

#endif